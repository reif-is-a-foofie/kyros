<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyros</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      font-family: 'Orbitron', 'Helvetica Neue', Arial, sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #links {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #ffd700; /* Gold color matching orbiting text */
      font-size: 36px;
      font-family: 'Helvetica', 'Arial', sans-serif;
      z-index: 10;
      white-space: nowrap;
      padding: 0 15px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4); /* Gold glow */
      font-weight: 500;
      background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700); /* Gold gradient */
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: shimmer 3s ease-in-out infinite alternate;
    }
    
    @keyframes shimmer {
      0% { filter: brightness(1) saturate(1); }
      100% { filter: brightness(1.2) saturate(1.3); }
    }
    @media (max-width: 768px) {
      #links {
        font-size: 32px;
        bottom: 15px;
        padding: 0 10px;
      }
    }
    @media (max-width: 480px) {
      #links {
        font-size: 28px;
        bottom: 10px;
      }
    }
    #links a {
      color: #ffd700; /* Gold color matching orbiting text */
      text-decoration: none;
      margin: 0 5px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4); /* Gold glow */
      background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700); /* Gold gradient */
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      transition: all 0.3s ease;
    }
    #links a:hover {
      filter: brightness(1.3) saturate(1.5);
      text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 60px rgba(255, 215, 0, 0.6);
    }
    
  </style>
</head>
<body>
  <div id="links">
    Kyros investment studio / <a href="mailto:hello@kyros.cc">hello@kyros.cc</a> / <a href="https://calendly.com/reif-kyros/30min" target="_blank">Pitch us</a>
  </div>


  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let camera, scene, renderer;
    let textMesh1;
    let earthModel;
    let group;
    let textOrbitRadius = 12;
    let earthRadius = 0;
    let sunLight;
    let orbitSpeed = 0.009;
    let earthRotationSpeed = 0.00275;
    let originalTextPositions = null; // Store original flat text positions
    
    // Multiple orbital objects
    let orbitalObjects = [];
    let orbitalGroups = [];
    let glbFiles = [
      'orbital_objects/tether_usdt.glb', 
      'orbital_objects/crystal_stone_rock.glb', 
      'orbital_objects/gameboy_classic.glb', 
      'orbital_objects/pizza.glb'
    ]; // Orbital objects around Earth
    let currentOrbitIndex = 0;
    let orbitalSpeedMultiplier = 0.5;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    let bubbles = [];
    let mouseX = 0;
    let mouseY = 0;
    let pointerX = 0, pointerY = 0;
    let pointerXOnPointerDown = 0, pointerYOnPointerDown = 0;
    let targetRotationX = 0, targetRotationY = 0;
    let targetRotationXOnPointerDown = 0, targetRotationYOnPointerDown = 0;
    let isPointerDown = false;
    let isMobile = window.innerWidth < 768;
    let isSmallMobile = window.innerWidth < 480;
    let orbitTime = 0;

    function updateResponsiveFlags() {
      isMobile = window.innerWidth < 768;
      isSmallMobile = window.innerWidth < 480;
    }

    function init() {
      console.log('üöÄ Starting Three.js initialization...');
      document.title = 'Kyros - Initializing';
      
      // Camera positioned to see entire Earth and orbiting text
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000); // Wider FOV
      camera.position.set(0, 0, 18);  // Closer to Earth to fill 80% of screen
      console.log('‚úÖ Camera created');

      // Scene with realistic deep space background
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e); // Dark blue space background instead of pure black
      scene.fog = new THREE.FogExp2(0x1a1a2e, 0.0003); // Lighter fog for better visibility
      console.log('‚úÖ Scene created with realistic space background');
      
      // Load space HDR environment map
      new RGBELoader().load('https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/space_1k.exr', (hdr) => {
        hdr.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = hdr;
        console.log('‚úÖ Space HDR environment map loaded');
      }, undefined, function(error) {
        console.log('‚ö†Ô∏è Space HDR load failed, using fallback:', error);
      });

      // Add much brighter ambient lighting
      scene.add(new THREE.AmbientLight(0xffffff, 2.0)); // Even brighter for better visibility
      
      // Add warm key light from user's right side (cinematic lighting)
      const sunLight = new THREE.DirectionalLight(0xfff8e1, 4.0); // Warm white for cinematic feel
      sunLight.position.set(15, 5, 10); // Much closer to scene
      sunLight.target.position.set(0, 0, 0); // Point at the Earth
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 4096; // Higher resolution shadows
      sunLight.shadow.mapSize.height = 4096;
      sunLight.shadow.camera.near = 0.5;
      sunLight.shadow.camera.far = 100; // Larger shadow area
      sunLight.shadow.camera.left = -50; // Wider shadow area
      sunLight.shadow.camera.right = 50;
      sunLight.shadow.camera.top = 50;
      sunLight.shadow.camera.bottom = -50;
      scene.add(sunLight);
      scene.add(sunLight.target);
      
      // Add warm back light for rim lighting
      const backLight = new THREE.PointLight(0xffd700, 4.0, 30); // Gold back light
      backLight.position.set(0, 0, -15); // Closer behind Earth
      scene.add(backLight);
      
      // Add Universal Studios-style rim light (cool contrast)
      const rimLight2 = new THREE.PointLight(0x88aaff, 2.5, 50);
      rimLight2.position.set(-10, 5, -10);
      scene.add(rimLight2);
      
      // Add cool fill light for contrast and color balance (closer)
      const fillLight = new THREE.DirectionalLight(0x88aaff, 1.2);
      fillLight.position.set(-15, -5, -10);
      scene.add(fillLight);
      
      // Add strategic colored lights for Universal Studios aesthetic
      const warmLight = new THREE.PointLight(0xffd700, 2.5, 40); // Gold accent light
      warmLight.position.set(20, 10, 15);
      scene.add(warmLight);
      
      const coolLight = new THREE.PointLight(0x88aaff, 2.0, 35); // Cool blue contrast
      coolLight.position.set(-20, -10, 15);
      scene.add(coolLight);
      
      const rimGold = new THREE.PointLight(0xffed4e, 1.8, 30); // Warm rim lighting
      rimGold.position.set(0, 20, 10);
      scene.add(rimGold);
      
      const fillCyan = new THREE.PointLight(0x88ffff, 1.5, 30); // Subtle cyan fill
      fillCyan.position.set(0, -20, 10);
      scene.add(fillCyan);
      
      // Add rim lights for better edge definition
      const rimLight1 = new THREE.DirectionalLight(0xffffff, 1.5);
      rimLight1.position.set(25, 0, 0);
      scene.add(rimLight1);
      
      const rimLight3 = new THREE.DirectionalLight(0xffffff, 1.5);
      rimLight3.position.set(-25, 0, 0);
      scene.add(rimLight3);
      
      console.log('‚úÖ Added space lighting');

      // Renderer (must be created first)
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      // Fix lighting and color accuracy with Universal Studios bloom
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 2.0; // Even higher exposure for maximum brightness
      
      document.body.appendChild(renderer.domElement);

      // --- Color calibration fix ---
      // Rebalance all lights to prevent over-saturation
      scene.traverse(o => {
        if (o.isLight) o.intensity *= 0.5; // Cut brightness in half
      });

      // Pizza-specific fix to restore natural colors
      setTimeout(() => {
        scene.traverse(o => {
          if (o.name && o.name.toLowerCase().includes('pizza')) {
            if (o.material) {
              o.material.emissive?.set(0x000000); // Kill baked glow
              o.material.emissiveIntensity = 0.0;
              o.material.color.set(0xffffff); // Use texture colors
              o.material.needsUpdate = true;
            }
          }
        });
      }, 3000); // Wait for pizza to load

      // Set up animation loop
      renderer.setAnimationLoop(animate);

      // No dynamic lighting for performance


      // Create orbital system - parent group rotates around Earth
      group = new THREE.Group();
      group.position.set(0, 0, 0);
      scene.add(group);

      updateResponsiveFlags();

      // Create simple starfield background
      createStarfield();
      console.log('‚úÖ Starfield created');

      // Load Earth model and create text
      loadEarth();
      createText();

      // Events
      document.addEventListener('pointerdown', onPointerDown);
      document.addEventListener('mousemove', onMouseMove);
      window.addEventListener('resize', onWindowResize);
      
      // Handle screen orientation change for mobile devices
      window.addEventListener('orientationchange', function() {
        setTimeout(onWindowResize, 100); // Small delay to ensure dimensions are updated
      }, false);
    }
    
    function onMouseMove(event) {
      mouseX = (event.clientX - windowHalfX) / 100;
      mouseY = (event.clientY - windowHalfY) / 100;
    }

    function createText() {
      console.log('üìù Creating 3D bubble text with realistic physics...');
      if (textMesh1) group.remove(textMesh1);

      // Load font and create bubble text
      const loader = new FontLoader();
    // Load Universal Secondaries font (authentic Universal Studios look)
    loader.load('Universal Secondary Web_Regular.json', function(font) {
      
      // Create single line of text
      createSingleLineText(font);
      
      // Update bottom text to use the same font
      updateBottomTextFont(font);
    }, undefined, function(error) {
      console.log('‚ö†Ô∏è Font load failed, using fallback text:', error);
      createFallbackText();
    });
    }

    function bendTextGeometry(geometry, radius, yOffset) {
      const pos = geometry.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const angle = x / radius;
        const newX = Math.sin(angle) * radius;
        const newZ = Math.cos(angle) * radius;
        pos.setX(i, newX);
        pos.setY(i, y + yOffset); // Add vertical offset for line separation
        pos.setZ(i, newZ);
      }
      pos.needsUpdate = true;
      geometry.computeVertexNormals();
    }

    function createSingleLineText(font) {
      const text = "build the change you wish to see in the world.";
      
        // Create clean Universal Studios-style text geometry with more depth
        const textGeometry = new TextGeometry(text, {
          font: font,
          size: isMobile ? 0.8 : 1.2,    // Clean size
          depth: 0.8,                    // More depth for 3D effect
          curveSegments: 20,             // Smooth curves
          bevelEnabled: true,            // Subtle bevels
          bevelThickness: 0.1,           // Thicker bevels for depth
          bevelSize: 0.05,               // Larger bevels
          bevelSegments: 8               // More bevel segments for smoothness
        });
      
      textGeometry.computeBoundingBox();
      textGeometry.center();
      
      // Calculate Earth circumference from actual loaded model
      let earthRadius = 2; // Default fallback
      let textOrbitRadius = 8; // Default fallback
      
      if (earthModel) {
        // Get actual Earth bounding box
        earthModel.updateMatrixWorld();
        const boundingBox = new THREE.Box3().setFromObject(earthModel);
        const size = boundingBox.getSize(new THREE.Vector3());
        earthRadius = Math.max(size.x, size.y, size.z) / 2;
        
        // Calculate circumference and set text orbit radius with clear offset (tighter orbit)
        const earthCircumference = 2 * Math.PI * earthRadius;
        textOrbitRadius = Math.max(earthRadius + (earthCircumference * 0.15), earthRadius + 3); // 15% of circumference above Earth with minimum 3 units
        
        console.log('üåç Earth radius calculated:', earthRadius);
        console.log('üåç Earth circumference:', earthCircumference);
        console.log('üåç Text orbit radius:', textOrbitRadius);
        } else {
          console.log('‚ö†Ô∏è Earth model not loaded yet, using default radius');
          // Use tighter default orbit for better visibility
          textOrbitRadius = 8;
        }
      
      // Store original flat positions for rebending (for both lines)
      const pos = textGeometry.attributes.position;
      originalTextPositions = new Float32Array(pos.array.length);
      originalTextPositions.set(pos.array, 0);
      
      // Bend text geometry to curve around Earth (facing outward)
      bendTextGeometry(textGeometry, textOrbitRadius, 0); // Single line centered

      // Create cinematic gold material (Universal Studios look)
        const textMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xffd700,        // Warm gold
          metalness: 1.0,         // Maximum metalness
          roughness: 0.25,        // Slight roughness for realism
          clearcoat: 1.0,         // Full clearcoat for glossy finish
          clearcoatRoughness: 0.1, // Slight clearcoat roughness
          envMapIntensity: 2.5,   // Strong environment reflections
          emissive: 0x442200,     // Warm gold emissive
          emissiveIntensity: 0.25, // Subtle gold glow
          side: THREE.DoubleSide, // Ensure both sides are rendered
          transparent: false,     // Ensure no transparency issues
          opacity: 1.0           // Fully opaque
        });

        // Create single text mesh
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        
        // Enable shadows for 3D depth
        textMesh.castShadow = true;
        textMesh.receiveShadow = true;
        
        // Make text face outward from Earth
        textMesh.rotation.y = Math.PI;
        
        // Add Universal Studios-style orbit tilt
        group.rotation.x = Math.PI / 8;  // Slight X-axis tilt
        group.rotation.z = Math.PI / 12; // Slight Z-axis tilt
        
        // Add curved text to orbital group
        group.add(textMesh);
        
        // Store reference to text mesh
        window.textMesh1 = textMesh;
        window.textMesh2 = textMesh; // Keep for compatibility
        
        // Keep text orbit flat (no tilt) - aligned with Earth's equator
        group.rotation.x = 0; // No tilt on X-axis
        group.rotation.z = 0; // No tilt on Z-axis
        
        console.log('üéØ Text orbit flat - aligned with Earth equator');
        
        // Store reference to original material for protection
        textMesh.userData.originalMaterial = textMaterial.clone();
        
        // Enable shadows for Earth model
        if (earthModel) {
          earthModel.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        }
        console.log('‚úÖ 3D bubble text created with realistic physics');
      
      // Start material protection loop
      startMaterialProtection();
      
      // Start introducing orbital objects one by one
      startOrbitalSequence();
    }


    function rebendTextGeometry() {
      if (!textMesh1 || !originalTextPositions) {
        console.log('‚ùå Cannot rebend: missing textMesh1 or originalTextPositions');
        return;
      }
      
      console.log('üîÑ Rebending text geometry with radius:', textOrbitRadius);
      
      const geometry = textMesh1.geometry;
      const pos = geometry.attributes.position;
      
      // Reset to original flat positions
      pos.array.set(originalTextPositions);
      
      // Now rebend with new radius
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const angle = x / textOrbitRadius;
        const newX = Math.sin(angle) * textOrbitRadius;
        const newZ = Math.cos(angle) * textOrbitRadius;
        pos.setX(i, newX);
        pos.setZ(i, newZ);
      }
      
      pos.needsUpdate = true;
      geometry.computeVertexNormals();
      
      console.log('‚úÖ Text geometry rebent successfully');
    }

    function startMaterialProtection() {
      // Continuously protect text material from being overridden
      setInterval(() => {
        const meshes = [window.textMesh1, window.textMesh2].filter(mesh => mesh && mesh.userData.originalMaterial);
        
        meshes.forEach(mesh => {
          // Check if material has been changed
          const currentMaterial = mesh.material;
          const originalMaterial = mesh.userData.originalMaterial;
          
          // If material color has changed from gold, restore it
          if (currentMaterial.color.getHex() !== 0xffd700 || 
              currentMaterial.emissive.getHex() !== 0xffd700) {
            console.log('üõ°Ô∏è Protecting text material from override');
            mesh.material = originalMaterial.clone();
            mesh.material.needsUpdate = true;
          }
        });
      }, 100); // Check every 100ms
    }

    function startOrbitalSequence() {
      console.log('üõ∞Ô∏è Starting orbital sequence with', glbFiles.length, 'objects');
      // Introduce orbital objects one by one with increasing delays
      for (let i = 0; i < glbFiles.length; i++) {
        setTimeout(() => {
          console.log('üöÄ Creating orbital object', i + 1, 'of', glbFiles.length);
          createOrbitalObject(i, 8 + (i * 3)); // Offset orbits: 8, 11, 14, 17
        }, 2000 + (i * 1500)); // 2s, 3.5s, 5s, 6.5s delays
      }
    }

    function createOrbitalObject(index, orbitRadius) {
      if (index >= glbFiles.length) return;
      
      console.log(`üõ∞Ô∏è Creating orbital object ${index + 1} at radius ${orbitRadius}`);
      
      // Create orbital group
      const orbitalGroup = new THREE.Group();
      orbitalGroups.push(orbitalGroup);
      
         // Add randomized orbital plane (more dynamic tilt variations)
         const tiltX = (Math.random() - 0.5) * 120; // Random tilt between -60 and +60 degrees
         const tiltY = (Math.random() - 0.5) * 60;  // Random Y-axis rotation for more variety
         const tiltZ = (Math.random() - 0.5) * 120; // Random tilt between -60 and +60 degrees
         orbitalGroup.rotation.x = tiltX * Math.PI / 180;
         orbitalGroup.rotation.y = tiltY * Math.PI / 180;
         orbitalGroup.rotation.z = tiltZ * Math.PI / 180;
      
      // Load GLB file for this orbit
      const loader = new GLTFLoader();
      const glbFile = glbFiles[index];
      
      console.log('üìÅ Loading GLB file:', glbFile);
      loader.load(glbFile, function(gltf) {
        console.log('‚úÖ GLB file loaded successfully:', glbFile);
        const model = gltf.scene.clone();
           
           // Calculate proper scale based on object's native dimensions
           const box = new THREE.Box3().setFromObject(model);
           const size = box.getSize(new THREE.Vector3());
           const maxDimension = Math.max(size.x, size.y, size.z);
           
           // Scale all objects to match the size of letter "A" from text
           const textSize = isMobile ? 0.8 : 1.2;
           const targetSize = textSize * 0.8; // 80% of text letter size
           const scale = targetSize / maxDimension;
           model.scale.setScalar(scale);
           
           console.log(`üìè Orbital object ${index + 1}: native size ${maxDimension.toFixed(2)}, scaled to ${(maxDimension * scale).toFixed(2)}`);
           
           // Position on orbit around Earth's center (0,0,0)
           model.position.set(orbitRadius, 0, 0);
           
           // Center the model's origin for proper rotation around Earth
           model.position.add(box.getCenter(new THREE.Vector3()).multiplyScalar(-scale));
           
           // Add random initial rotation
           model.rotation.set(
             Math.random() * Math.PI * 2,
             Math.random() * Math.PI * 2,
             Math.random() * Math.PI * 2
           );
           
           // Store tumbling speeds for natural orbiting motion
           model.userData.tumbleX = (Math.random() - 0.5) * 0.02; // Random tumble speeds
           model.userData.tumbleY = (Math.random() - 0.5) * 0.02;
           model.userData.tumbleZ = (Math.random() - 0.5) * 0.02;
           
           // Store individual orbital speed (0.1 to 0.5 of text orbit speed)
           model.userData.orbitalSpeed = 0.1 + Math.random() * 0.4; // Random between 0.1 and 0.5
           
           // Fix materials for orbital objects - ensure they're properly lit and colored
           model.traverse((child) => {
             if (child.isMesh) {
               // Enable shadows
               child.castShadow = true;
               child.receiveShadow = true;
               
               // Fix grey materials - enhance lighting and colors
               if (child.material) {
                 // Make materials more visible
                 if (child.material.map) {
                   child.material.map.colorSpace = THREE.SRGBColorSpace;
                 }
                 
           // Always add emissive for visibility - stronger for stone and coin
           let emissiveColor = new THREE.Color(0x444444);
           let emissiveIntensity = 0.6;
           
           // Special glow colors for different objects
           if (glbFile.includes('stone')) {
             emissiveColor = new THREE.Color(0x8888ff); // Blue glow for stone
             emissiveIntensity = 1.2;
           } else if (glbFile.includes('tether') || glbFile.includes('coin')) {
             emissiveColor = new THREE.Color(0xffff88); // Yellow glow for coin
             emissiveIntensity = 1.2;
           } else if (glbFile.includes('gameboy')) {
             emissiveColor = new THREE.Color(0x88ff88); // Green glow for gameboy
             emissiveIntensity = 0.8;
           } else if (glbFile.includes('pizza')) {
             emissiveColor = new THREE.Color(0xff8888); // Red glow for pizza
             emissiveIntensity = 0.8;
           }
           
           child.material.emissive = emissiveColor;
           child.material.emissiveIntensity = emissiveIntensity;
                 
                 // Force brighten ALL materials to make them visible
                 if (child.material.color) {
                   // Multiply color by 2 to make it much brighter
                   child.material.color.multiplyScalar(2.0);
                 }
                 
                 // Reduce roughness for better reflections
                 if (child.material.roughness !== undefined) {
                   child.material.roughness = Math.min(child.material.roughness, 0.5);
                 }
                 
                 // Ensure material is properly configured
                 child.material.needsUpdate = true;
                 
                 console.log(`üé® Fixed material for ${glbFile}: color=${child.material.color.getHexString()}`);
               }
             }
           });
           
           // Ensure model is not clipped and properly positioned
           model.traverse((child) => {
             if (child.isMesh) {
               child.frustumCulled = false; // Prevent clipping
             }
           });
           
           // Add to orbital group
           orbitalGroup.add(model);
           orbitalObjects.push(model);
           
           // Add orbital group directly to scene (not nested under Earth)
           scene.add(orbitalGroup);
           
           console.log(`‚úÖ Orbital object ${index + 1} added directly to scene (not nested under Earth)`);
           
           console.log(`‚úÖ Orbital object ${index + 1} (${glbFile}) added to scene with enhanced lighting`);
           console.log(`üìä Total orbital objects loaded: ${orbitalObjects.length}`);
         }, function(progress) {
        console.log(`üìä Loading orbital object ${index + 1}:`, (progress.loaded / progress.total * 100) + '%');
      }, function(error) {
        console.log(`‚ö†Ô∏è Failed to load orbital object ${index + 1}:`, error);
      });
    }

    function createFallbackText() {
      // Fallback canvas text if font fails
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = isMobile ? 800 : 1200;
      canvas.height = isMobile ? 200 : 300;
      
      const fontSize = isMobile ? 20 : 28;
      const lineHeight = fontSize * 1.3;
      
      ctx.font = `bold ${fontSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#9fd6ff';
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      ctx.fillText('build the change you wish to see', centerX, centerY - lineHeight/2);
      ctx.fillText('in the world', centerX, centerY + lineHeight/2);
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      
      const planeWidth = isMobile ? 16 : 24;
      const planeHeight = isMobile ? 5 : 7;
      
      textMesh1 = new THREE.Mesh(new THREE.PlaneGeometry(planeWidth, planeHeight), material);
      textMesh1.position.set(0, 0, 0);
      textMesh1.rotation.y = Math.PI;
      group.add(textMesh1);
      console.log('‚úÖ Fallback text created');
    }

    function loadEarth() {
      console.log('üåç Loading Earth model...');
      const loader = new GLTFLoader();
      
      // Try GLB first
      console.log('üîç Attempting to load earth.glb...');
      loader.load('earth.glb', function(gltf) {
        console.log('‚úÖ Earth GLB loaded successfully');
        earthModel = gltf.scene;
        
        // Keep original materials from GLTF - don't override them
        earthModel.scale.setScalar(2);
        earthModel.position.set(0, 0, 0);
        
        // Add Earth directly to scene (not in rotating group)
        scene.add(earthModel);
        console.log('‚úÖ Earth GLB model loaded with original materials');
      }, function(progress) {
        console.log('üìä GLB loading progress:', (progress.loaded / progress.total * 100) + '%');
      }, function(error) {
        console.log('‚ö†Ô∏è Earth GLB load failed:', error);
        
        // Reset loader path and try GLTF
        loader.setPath('earth_gltf/');
        console.log('üîç Attempting to load GLTF from earth_gltf/scene.gltf...');
        loader.load('scene.gltf', function(gltf) {
          console.log('‚úÖ Earth GLTF loaded successfully');
          earthModel = gltf.scene;
          
          // Keep original materials from GLTF - don't override them
          earthModel.scale.setScalar(2);
          earthModel.position.set(0, 0, 0);
          
          // Add Earth directly to scene (not in rotating group)
          scene.add(earthModel);
          console.log('‚úÖ Earth GLTF model loaded with original materials');
        }, function(progress) {
          console.log('üìä GLTF loading progress:', (progress.loaded / progress.total * 100) + '%');
        }, function(error2) {
          console.log('‚ö†Ô∏è Earth GLTF also failed:', error2);
          console.log('‚ùå No Earth model could be loaded');
        });
      });
    }


    // Create circular star texture
    // Update bottom text to use the same font as orbiting text
    function updateBottomTextFont(font) {
      const linksElement = document.getElementById('links');
      if (linksElement) {
        linksElement.style.fontFamily = "'Universal Secondary Web', 'Helvetica', 'Arial', sans-serif";
        console.log('‚úÖ Bottom text updated to use Universal Secondary Web font');
      }
    }

    function createStarTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      
      // Create radial gradient for circular star
      const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
      gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      
      context.fillStyle = gradient;
      context.fillRect(0, 0, 64, 64);
      
      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }

    function createStarfield() {
      // Create dramatic starfield background
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 400; // Much fewer stars for dramatic effect
      const starPositions = new Float32Array(starCount * 3);
      const starColors = new Float32Array(starCount * 3);
      const starSizes = new Float32Array(starCount);
      
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        
        // Random positions in a sphere
        const radius = Math.random() * 1000 + 500;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        
        starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        starPositions[i3 + 2] = radius * Math.cos(phi);
        
          // Bright star colors (5x brighter)
          const colorVariation = Math.random();
          if (colorVariation < 0.7) {
            // Bright white/blue stars
            starColors[i3] = 1.0;     // Maximum brightness
            starColors[i3 + 1] = 1.0; // Maximum brightness
            starColors[i3 + 2] = 1.0; // Maximum brightness
          } else if (colorVariation < 0.9) {
            // Bright yellow stars
            starColors[i3] = 1.0;
            starColors[i3 + 1] = 1.0;
            starColors[i3 + 2] = 0.8;
          } else {
            // Bright red stars
            starColors[i3] = 1.0;
            starColors[i3 + 1] = 0.8;
            starColors[i3 + 2] = 0.6;
          }
          
          // Larger, more dramatic star sizes
          starSizes[i] = Math.random() * 8 + 3; // 3-11 size range
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
      starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
      
        const starMaterial = new THREE.PointsMaterial({
          size: 6,              // Larger stars for better visibility
          transparent: true,
          opacity: 1.0,         // Fully opaque for maximum brightness
          vertexColors: true,
          sizeAttenuation: false,
          alphaTest: 0.1,
          blending: THREE.AdditiveBlending, // Makes stars circular and glow
          map: createStarTexture(), // Custom circular star texture
          depthWrite: false     // Prevent z-fighting
        });
      
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
      
      // Add twinkling animation
      window.stars = stars; // Store reference for animation
      window.starColors = starColors; // Store colors for animation
      
      console.log('‚úÖ Realistic starfield created with', starCount, 'varied stars');
    }


    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      updateResponsiveFlags();
      
      // Recreate text with responsive sizing
      createText();
      console.log('üéâ Three.js initialization complete!');
    }

    // Initialize after DOM is ready
    init();

    function onPointerDown(event) {
      if (event.isPrimary === false) return;
      isPointerDown = true;
      pointerXOnPointerDown = event.clientX - windowHalfX;
      pointerYOnPointerDown = event.clientY - windowHalfY;
      targetRotationXOnPointerDown = targetRotationX;
      targetRotationYOnPointerDown = targetRotationY;
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerup', onPointerUp);
    }

    function onPointerMove(event) {
      if (event.isPrimary === false) return;
      pointerX = event.clientX - windowHalfX;
      pointerY = event.clientY - windowHalfY;
      targetRotationY = targetRotationYOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
      targetRotationX = targetRotationXOnPointerDown + (pointerY - pointerYOnPointerDown) * 0.02;
      
      // Clamp rotations to keep text readable - tighter range for better bubble density
      targetRotationY = Math.max(-Math.PI / 6, Math.min(Math.PI / 6, targetRotationY)); // ¬±30¬∞
      targetRotationX = Math.max(-Math.PI / 8, Math.min(Math.PI / 8, targetRotationX)); // ¬±22.5¬∞
    }

    function onPointerUp(event) {
      if (event.isPrimary === false) return;
      isPointerDown = false;
      document.removeEventListener('pointermove', onPointerMove);
      document.removeEventListener('pointerup', onPointerUp);
    }

    function animate(t) {
      // Only log once to avoid spam
      if (!animate.logged) {
        console.log('üé¨ Animation loop started');
        animate.logged = true;
      }
      
      const time = (t || 0) * 0.0001;
      
      // Orbital animation - rotate the entire group around Y-axis (like Universal Studios)
      group.rotation.y -= orbitSpeed; // Use control variable
      
         // Rotate all orbital groups with individual speeds and add tumbling
         orbitalGroups.forEach((orbitalGroup, index) => {
           // Use individual orbital speed for each object (0.1 to 0.5 of text speed)
           const groupSpeed = orbitalGroup.children[0]?.userData.orbitalSpeed || 0.3;
           orbitalGroup.rotation.y += orbitSpeed * groupSpeed;
           
           // Add tumbling motion to each orbital object
           orbitalGroup.children.forEach((child) => {
             if (child.userData.tumbleX !== undefined) {
               child.rotation.x += child.userData.tumbleX;
               child.rotation.y += child.userData.tumbleY;
               child.rotation.z += child.userData.tumbleZ;
             }
           });
         });
      
      // Earth rotates slowly in opposite direction (1/4 speed of text)
      if (earthModel) {
        earthModel.rotation.y += earthRotationSpeed; // Use control variable
      }
      
      // Curved text doesn't need to face camera - it's already oriented outward
      
      // Click-to-pan camera controls (only when pointer is down)
      let targetX = 0, targetY = 0;
      if (isPointerDown) {
        targetX = -mouseX * 0.8;  // Reduced sensitivity
        targetY = mouseY * 0.8;   // Reduced sensitivity
      }
      
        // Smooth camera movement around the orbital system
      camera.position.x += (targetX - camera.position.x) * 0.08;
      camera.position.y += (targetY - camera.position.y) * 0.08;
        camera.position.z = 18; // Keep camera closer to fill 80% of screen with Earth
      
      // Always look at the orbital center
      camera.lookAt(0, 0, 0);
      
        // Animate star twinkling with more dynamic patterns (never disappear)
        if (window.stars && window.starColors) {
          const colors = window.stars.geometry.attributes.color.array;
          const time = (t || 0) * 0.002; // Faster animation
          
          for (let i = 0; i < window.starColors.length; i += 3) {
            const starIndex = i / 3;
            // Different twinkle patterns for variety - always keep minimum brightness
            const pattern1 = Math.sin(time * 3 + starIndex * 0.2) * 0.3 + 0.7; // 0.4 to 1.0
            const pattern2 = Math.sin(time * 5 + starIndex * 0.15) * 0.2 + 0.8; // 0.6 to 1.0
            const pattern3 = Math.sin(time * 2 + starIndex * 0.3) * 0.4 + 0.6; // 0.2 to 1.0
            
            // Mix different patterns for each star - ensure minimum 0.4 brightness
            const twinkle = Math.max(0.4, (pattern1 + pattern2 + pattern3) / 3);
            
            // Add occasional bright flashes
            const flash = Math.random() > 0.98 ? 1.5 : 1.0;
            
            colors[i] = window.starColors[i] * twinkle * flash;     // Red
            colors[i + 1] = window.starColors[i + 1] * twinkle * flash; // Green
            colors[i + 2] = window.starColors[i + 2] * twinkle * flash; // Blue
          }
          window.stars.geometry.attributes.color.needsUpdate = true;
        }
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
