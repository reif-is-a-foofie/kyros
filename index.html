<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Build â€” 14 Fonts, Metallic Gold</title>
  <style>
    html,body {margin:0;height:100%;background:#000;overflow:hidden;}
    canvas {display:block;cursor:pointer;}
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barrio:wght@400&family=Fredoka+One:wght@400&family=Grenze+Gotisch:wght@700&family=Londrina+Shadow:wght@400&family=Press+Start+2P&family=Rye:wght@400&family=Spicy+Rice&family=Trade+Winds:wght@400&family=UnifrakturMaguntia:wght@400&family=Orbitron:wght@700&family=Righteous:wght@400&family=Alfa+Slab+One:wght@400&family=Bungee:wght@400&family=Rubik+Wet+Paint:wght@400&display=swap" rel="stylesheet">
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js';
    import gsap from 'https://cdn.jsdelivr.net/npm/gsap@3.12.5/+esm';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(35, innerWidth/innerHeight, 0.1, 1000);
    camera.position.z = 200;

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.8;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Bright environment for strong reflections
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    const envScene = new THREE.Scene();
    envScene.background = new THREE.Color(0xffffff);
    
    // Ultra-bright studio lighting setup for strong reflections
    const studioLight1 = new THREE.DirectionalLight(0xffffff, 15);
    studioLight1.position.set(10, 10, 5);
    envScene.add(studioLight1);
    
    const studioLight2 = new THREE.DirectionalLight(0xffdd88, 12);
    studioLight2.position.set(-8, 6, -3);
    envScene.add(studioLight2);
    
    const studioLight3 = new THREE.DirectionalLight(0x88aaff, 10);
    studioLight3.position.set(0, -5, 8);
    envScene.add(studioLight3);
    
    const studioLight4 = new THREE.DirectionalLight(0xff6666, 8);
    studioLight4.position.set(5, -8, -5);
    envScene.add(studioLight4);
    
    const ambientFill = new THREE.AmbientLight(0xffffff, 5);
    envScene.add(ambientFill);
    
    scene.environment = pmremGenerator.fromScene(envScene).texture;
    pmremGenerator.dispose();

    // Realistic lighting setup
    const warmAmbient = new THREE.AmbientLight(0xffdd88, 0.6);
    scene.add(warmAmbient);
    
    const keyLight = new THREE.DirectionalLight(0xffdd88, 3.0);
    keyLight.position.set(15, 20, 10);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.setScalar(2048);
    keyLight.shadow.camera.near = 0.1;
    keyLight.shadow.camera.far = 50;
    keyLight.shadow.camera.left = -10;
    keyLight.shadow.camera.right = 10;
    keyLight.shadow.camera.top = 10;
    keyLight.shadow.camera.bottom = -10;
    scene.add(keyLight);
    
    const rimLight = new THREE.DirectionalLight(0x88aaff, 1.5);
    rimLight.position.set(-10, 5, -15);
    scene.add(rimLight);
    
    const fillLight = new THREE.DirectionalLight(0xffaa66, 0.8);
    fillLight.position.set(5, -10, 5);
    scene.add(fillLight);

    // Starfield
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 300;
    const starPositions = new Float32Array(starCount * 3);
    
    for(let i = 0; i < starCount; i++){
      const spread = 300;
      starPositions[i * 3] = (Math.random() - 0.5) * spread;
      starPositions[i * 3 + 1] = (Math.random() - 0.5) * spread;
      starPositions[i * 3 + 2] = -150 + Math.random() * 100;
    }
    
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMaterial = new THREE.PointsMaterial({size: 2, color: 0xffffff, transparent: true, opacity: 0.8});
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Mirror-like gold material
    const goldMaterial = new THREE.MeshPhysicalMaterial({
      color: 0xffd700,           // Pure gold color
      metalness: 1.0,            // Perfect metal
      roughness: 0.0,            // Perfect mirror surface
      clearcoat: 1.0,            // Full clearcoat
      clearcoatRoughness: 0.0,   // Perfect clearcoat
      envMapIntensity: 15.0,     // Very strong environment reflection
      ior: 0.17,                 // Gold's actual index of refraction
      reflectivity: 1.0,         // Maximum reflectivity
      transmission: 0.0,         // No transmission (solid metal)
      thickness: 0.0,            // No thickness (solid metal)
      side: THREE.DoubleSide
    });

    // Particle system
    const maxPoints = 30000;
    const sphereGeometry = new THREE.SphereGeometry(0.06, 8, 8);
    const instancedMesh = new THREE.InstancedMesh(sphereGeometry, goldMaterial, maxPoints);
    scene.add(instancedMesh);

    const positions = new Float32Array(maxPoints * 3);
    const targetPositions = new Float32Array(maxPoints * 3);
    const matrix = new THREE.Matrix4();
    const tempPos = new THREE.Vector3();
    let uProgress = 0;

    // Fonts array - only great fonts
    const fonts = [
      '80px "Barrio", cursive',
      '80px "Fredoka One", cursive',
      '80px "Grenze Gotisch", cursive',
      '80px "Londrina Shadow", cursive',
      '80px "Press Start 2P", monospace',
      '80px "Rye", cursive',
      '80px "Spicy Rice", cursive',
      '80px "Trade Winds", cursive',
      '80px "UnifrakturMaguntia", cursive',
      '80px "Orbitron", monospace',
      '80px "Righteous", cursive',
      '80px "Alfa Slab One", cursive',
      '80px "Bungee", cursive',
      '80px "Rubik Wet Paint", cursive'
    ];

    // Sample text with 4 depth layers
    function sampleText(word, fontIndex){
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = fonts[fontIndex];
      const metrics = ctx.measureText(word);
      const width = Math.ceil(metrics.width) + 20;
      const height = 100;
      
      canvas.width = width;
      canvas.height = height;
      ctx.font = fonts[fontIndex];
      ctx.fillStyle = 'white';
      ctx.textBaseline = 'middle';
      ctx.fillText(word, 10, height/2);
      
      const imageData = ctx.getImageData(0, 0, width, height);
      const pixels = [];
      
      const depthLayers = 4;
      const depthStep = 0.15;
      const step = 1;
      const scale = 0.12;
      
      for(let y = 0; y < height; y += step) {
        for(let x = 0; x < width; x += step) {
          const i = (y * width + x) * 4;
          if(imageData.data[i] > 128) {
            for(let z = 0; z < depthLayers; z++) {
              pixels.push(
                (x - width/2) * scale,
                (height/2 - y) * scale,
                (z - 1.5) * depthStep
              );
            }
          }
        }
      }
      
      const out = new Float32Array(maxPoints * 3);
      const textParticleCount = pixels.length / 3;
      
      for (let i = 0; i < maxPoints; i++) {
        const sourceIndex = (i % textParticleCount) * 3;
        out[i * 3] = pixels[sourceIndex];
        out[i * 3 + 1] = pixels[sourceIndex + 1];
        out[i * 3 + 2] = pixels[sourceIndex + 2];
      }
      
      return out;
    }

    // Wait for fonts to load, then build combos
    async function buildCombos(){
      // Wait for all fonts to load
      await document.fonts.ready;
      
      const combos = [];
      for(let i = 0; i < fonts.length; i++){
        // Ensure each font is loaded
        await document.fonts.load(fonts[i]);
        const pts = sampleText('build', i);
        combos.push({pts, surface: goldMaterial, word: 'build', font: fonts[i]});
      }
      
      return combos;
    }
    
    // Initialize after fonts load
    const combos = await buildCombos();

    // Initialize with first font
    positions.set(combos[0].pts);
    targetPositions.set(combos[0].pts);
    
    for(let i = 0; i < maxPoints; i++){
      matrix.setPosition(positions[i*3], positions[i*3+1], positions[i*3+2]);
      instancedMesh.setMatrixAt(i, matrix);
    }
    instancedMesh.instanceMatrix.needsUpdate = true;

    // Morphing functionality
    let morphIndex = 0;
    let currentTween = null;
    
    function morphTo(index){
      // Kill any existing animation
      if(currentTween) {
        currentTween.kill();
      }
      
      const c = combos[index];
      targetPositions.set(c.pts);
      
      console.log(`Starting 10-second morph to font ${index}`);
      
      currentTween = gsap.to({uProgress: 0}, {
        uProgress: 1,
        duration: 10,
        ease: "power2.inOut",
        onUpdate: function(){
          uProgress = this.targets()[0].uProgress;
          
          // Update positions
          for(let i = 0; i < maxPoints; i++){
            positions[i*3] = THREE.MathUtils.lerp(positions[i*3], targetPositions[i*3], uProgress);
            positions[i*3+1] = THREE.MathUtils.lerp(positions[i*3+1], targetPositions[i*3+1], uProgress);
            positions[i*3+2] = THREE.MathUtils.lerp(positions[i*3+2], targetPositions[i*3+2], uProgress);
            
            matrix.setPosition(positions[i*3], positions[i*3+1], positions[i*3+2]);
            instancedMesh.setMatrixAt(i, matrix);
          }
          instancedMesh.instanceMatrix.needsUpdate = true;
        },
        onComplete: function(){
          positions.set(targetPositions);
          uProgress = 0;
          currentTween = null;
          console.log(`Morph to font ${index} complete`);
        }
      });
    }

    // Click to morph
    document.addEventListener('click', () => {
      morphIndex = (morphIndex + 1) % combos.length;
      console.log(`Morphing to font ${morphIndex}: ${combos[morphIndex].font}`);
      morphTo(morphIndex);
    });

    function animate(t){
      // Gentle rotation
      instancedMesh.rotation.y = Math.sin(t * 0.0002) * 0.3;
      instancedMesh.rotation.x = Math.cos(t * 0.00015) * 0.15;
      
      // Slow camera pan
      const panSpeed = 0.0001;
      const panX = Math.sin(t * panSpeed) * 25;
      const panY = Math.cos(t * panSpeed * 0.7) * 15;
      
      camera.position.set(panX, panY, 200);
      camera.lookAt(0, 0, 0);
      
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
