<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Build â€” 14 Fonts, Metallic Gold</title>
  <style>
    html,body {margin:0;height:100%;background:#000;overflow:hidden;}
    canvas {display:block;cursor:pointer;}
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barrio:wght@400&family=Chiller:wght@400&family=Comic+Neue:wght@700&family=Courier+Prime:wght@700&family=Creepster&family=Fredoka+One:wght@400&family=Grenze+Gotisch:wght@700&family=Londrina+Shadow:wght@400&family=Papyrus:wght@400&family=Press+Start+2P&family=Rye:wght@400&family=Spicy+Rice&family=Trade+Winds:wght@400&family=UnifrakturMaguntia:wght@400&display=swap" rel="stylesheet">
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js';
    import gsap from 'https://cdn.jsdelivr.net/npm/gsap@3.12.5/+esm';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(35, innerWidth/innerHeight, 0.1, 1000);
    camera.position.z = 200;

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 2.0;
    document.body.appendChild(renderer.domElement);

    // Simple environment for reflections
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    const envScene = new THREE.Scene();
    envScene.background = new THREE.Color(0xcccccc);
    envScene.add(new THREE.AmbientLight(0xffffff, 2));
    scene.environment = pmremGenerator.fromScene(envScene).texture;
    pmremGenerator.dispose();

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 1.5));
    const keyLight = new THREE.DirectionalLight(0xffffff, 4.0);
    keyLight.position.set(10, 15, 10);
    scene.add(keyLight);
    
    const fillLight = new THREE.DirectionalLight(0x6688ff, 1.2);
    fillLight.position.set(-8, 5, -8);
    scene.add(fillLight);

    // Starfield
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 300;
    const starPositions = new Float32Array(starCount * 3);
    
    for(let i = 0; i < starCount; i++){
      const spread = 300;
      starPositions[i * 3] = (Math.random() - 0.5) * spread;
      starPositions[i * 3 + 1] = (Math.random() - 0.5) * spread;
      starPositions[i * 3 + 2] = -150 + Math.random() * 100;
    }
    
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMaterial = new THREE.PointsMaterial({size: 2, color: 0xffffff, transparent: true, opacity: 0.8});
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Gold material
    const goldMaterial = new THREE.MeshPhysicalMaterial({
      color: 0xd4af37,
      metalness: 1.0,
      roughness: 0,
      clearcoat: 1,
      clearcoatRoughness: 0,
      envMapIntensity: 10.0,
      side: THREE.DoubleSide
    });

    // Particle system
    const maxPoints = 30000;
    const sphereGeometry = new THREE.SphereGeometry(0.08, 6, 6);
    const instancedMesh = new THREE.InstancedMesh(sphereGeometry, goldMaterial, maxPoints);
    scene.add(instancedMesh);

    const positions = new Float32Array(maxPoints * 3);
    const targetPositions = new Float32Array(maxPoints * 3);
    const matrix = new THREE.Matrix4();
    const tempPos = new THREE.Vector3();
    let uProgress = 0;

    // Fonts array
    const fonts = [
      '80px "Barrio", cursive',
      '80px "Chiller", fantasy', 
      '80px "Comic Neue", cursive',
      '80px "Courier Prime", monospace',
      '80px "Creepster", fantasy',
      '80px "Fredoka One", cursive',
      '80px "Grenze Gotisch", cursive',
      '80px "Londrina Shadow", cursive',
      '80px "Papyrus", fantasy',
      '80px "Press Start 2P", monospace',
      '80px "Rye", cursive',
      '80px "Spicy Rice", cursive',
      '80px "Trade Winds", cursive',
      '80px "UnifrakturMaguntia", cursive'
    ];

    // Sample text with 4 depth layers
    function sampleText(word, fontIndex){
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = fonts[fontIndex];
      const metrics = ctx.measureText(word);
      const width = Math.ceil(metrics.width) + 20;
      const height = 100;
      
      canvas.width = width;
      canvas.height = height;
      ctx.font = fonts[fontIndex];
      ctx.fillStyle = 'white';
      ctx.textBaseline = 'middle';
      ctx.fillText(word, 10, height/2);
      
      const imageData = ctx.getImageData(0, 0, width, height);
      const pixels = [];
      
      const depthLayers = 4;
      const depthStep = 0.3;
      const step = 1;
      const scale = 0.15;
      
      for(let y = 0; y < height; y += step) {
        for(let x = 0; x < width; x += step) {
          const i = (y * width + x) * 4;
          if(imageData.data[i] > 128) {
            for(let z = 0; z < depthLayers; z++) {
              pixels.push(
                (x - width/2) * scale,
                (height/2 - y) * scale,
                (z - 1.5) * depthStep
              );
            }
          }
        }
      }
      
      const out = new Float32Array(maxPoints * 3);
      const textParticleCount = pixels.length / 3;
      
      for (let i = 0; i < maxPoints; i++) {
        const sourceIndex = (i % textParticleCount) * 3;
        out[i * 3] = pixels[sourceIndex];
        out[i * 3 + 1] = pixels[sourceIndex + 1];
        out[i * 3 + 2] = pixels[sourceIndex + 2];
      }
      
      return out;
    }

    // Build combos for all fonts
    const combos = [];
    for(let i = 0; i < fonts.length; i++){
      const pts = sampleText('build', i);
      combos.push({pts, surface: goldMaterial, word: 'build', font: fonts[i]});
    }

    // Initialize with first font
    positions.set(combos[0].pts);
    targetPositions.set(combos[0].pts);
    
    for(let i = 0; i < maxPoints; i++){
      matrix.setPosition(positions[i*3], positions[i*3+1], positions[i*3+2]);
      instancedMesh.setMatrixAt(i, matrix);
    }
    instancedMesh.instanceMatrix.needsUpdate = true;

    // Morphing functionality
    let morphIndex = 0;
    function morphTo(index){
      const c = combos[index];
      targetPositions.set(c.pts);
      
      gsap.to({uProgress: 0}, {
        uProgress: 1,
        duration: 2,
        ease: "power2.inOut",
        onUpdate: function(){
          uProgress = this.targets()[0].uProgress;
          
          // Update positions
          for(let i = 0; i < maxPoints; i++){
            positions[i*3] = THREE.MathUtils.lerp(positions[i*3], targetPositions[i*3], uProgress);
            positions[i*3+1] = THREE.MathUtils.lerp(positions[i*3+1], targetPositions[i*3+1], uProgress);
            positions[i*3+2] = THREE.MathUtils.lerp(positions[i*3+2], targetPositions[i*3+2], uProgress);
            
            matrix.setPosition(positions[i*3], positions[i*3+1], positions[i*3+2]);
            instancedMesh.setMatrixAt(i, matrix);
          }
          instancedMesh.instanceMatrix.needsUpdate = true;
        },
        onComplete: function(){
          positions.set(targetPositions);
          uProgress = 0;
        }
      });
    }

    // Click to morph
    document.addEventListener('click', () => {
      morphIndex = (morphIndex + 1) % combos.length;
      morphTo(morphIndex);
    });

    function animate(t){
      // Gentle rotation
      instancedMesh.rotation.y = Math.sin(t * 0.0002) * 0.3;
      instancedMesh.rotation.x = Math.cos(t * 0.00015) * 0.15;
      
      // Slow camera pan
      const panSpeed = 0.0001;
      const panX = Math.sin(t * panSpeed) * 25;
      const panY = Math.cos(t * panSpeed * 0.7) * 15;
      
      camera.position.set(panX, panY, 200);
      camera.lookAt(0, 0, 0);
      
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
