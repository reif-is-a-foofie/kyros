<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Build â€” 14 Fonts, Metallic Gold</title>
  <style>
    html,body {margin:0;height:100%;background:#fff;overflow:hidden;}
    canvas {display:block;cursor:pointer;}
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barrio:wght@400&family=Fredoka+One:wght@400&family=Grenze+Gotisch:wght@700&family=Londrina+Shadow:wght@400&family=Press+Start+2P&family=Rye:wght@400&family=Spicy+Rice&family=Trade+Winds:wght@400&family=UnifrakturMaguntia:wght@400&family=Orbitron:wght@700&family=Righteous:wght@400&family=Alfa+Slab+One:wght@400&family=Bungee:wght@400&family=Rubik+Wet+Paint:wght@400&display=swap" rel="stylesheet">
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js';
    import gsap from 'https://cdn.jsdelivr.net/npm/gsap@3.12.5/+esm';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(35, innerWidth/innerHeight, 0.1, 1000);
    camera.position.z = 200;

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.8;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.autoClear = true;  // Ensure buffer clears every frame
    document.body.appendChild(renderer.domElement);

    // Bright environment for strong reflections
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    const envScene = new THREE.Scene();
    envScene.background = new THREE.Color(0xffffff);
    
    // Ultra-bright studio lighting setup for strong reflections
    const studioLight1 = new THREE.DirectionalLight(0xffffff, 15);
    studioLight1.position.set(10, 10, 5);
    envScene.add(studioLight1);
    
    const studioLight2 = new THREE.DirectionalLight(0xffdd88, 12);
    studioLight2.position.set(-8, 6, -3);
    envScene.add(studioLight2);
    
    const studioLight3 = new THREE.DirectionalLight(0x88aaff, 10);
    studioLight3.position.set(0, -5, 8);
    envScene.add(studioLight3);
    
    const studioLight4 = new THREE.DirectionalLight(0xff6666, 8);
    studioLight4.position.set(5, -8, -5);
    envScene.add(studioLight4);
    
    const ambientFill = new THREE.AmbientLight(0xffffff, 5);
    envScene.add(ambientFill);
    
    scene.environment = pmremGenerator.fromScene(envScene).texture;
    pmremGenerator.dispose();

    // Realistic lighting setup
    const warmAmbient = new THREE.AmbientLight(0xffdd88, 0.6);
    scene.add(warmAmbient);
    
    const keyLight = new THREE.DirectionalLight(0xffdd88, 3.0);
    keyLight.position.set(15, 20, 10);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.setScalar(2048);
    keyLight.shadow.camera.near = 0.1;
    keyLight.shadow.camera.far = 50;
    keyLight.shadow.camera.left = -10;
    keyLight.shadow.camera.right = 10;
    keyLight.shadow.camera.top = 10;
    keyLight.shadow.camera.bottom = -10;
    scene.add(keyLight);
    
    const rimLight = new THREE.DirectionalLight(0x88aaff, 1.5);
    rimLight.position.set(-10, 5, -15);
    scene.add(rimLight);
    
    const fillLight = new THREE.DirectionalLight(0xffaa66, 0.8);
    fillLight.position.set(5, -10, 5);
    scene.add(fillLight);

    // No starfield - clean background

    // Darker matte black material
    const solidGold = new THREE.MeshStandardMaterial({
      color: 0x000000,           // Pure black color
      metalness: 0.0,            // No metalness
      roughness: 1.0,            // Maximum roughness - matte finish
      emissive: 0x000000,        // No emission
      side: THREE.DoubleSide,
      flatShading: true          // Flat shading for darker, more solid look
    });

    // Particle system
    const maxPoints = 80000;  // More particles for denser sampling
    const sphereGeometry = new THREE.SphereGeometry(0.04, 6, 6);  // Slightly larger spheres for darker fill
    const instancedMesh = new THREE.InstancedMesh(sphereGeometry, solidGold, maxPoints);
    scene.add(instancedMesh);

    // Three position arrays for clean control
    const basePositions = new Float32Array(maxPoints * 3);     // current word shape
    const dispersedOffsets = new Float32Array(maxPoints * 3);  // random explosion offsets
    const targetPositions = new Float32Array(maxPoints * 3);   // next word shape
    
    const matrix = new THREE.Matrix4();
    const tempPos = new THREE.Vector3();
    let currentTween = null;

    // Fonts array for "build" - only great fonts
    const buildFonts = [
      '80px "Barrio", cursive',
      '80px "Fredoka One", cursive',
      '80px "Grenze Gotisch", cursive',
      '80px "Londrina Shadow", cursive',
      '80px "Press Start 2P", monospace',
      '80px "Rye", cursive',
      '80px "Spicy Rice", cursive',
      '80px "Trade Winds", cursive',
      '80px "UnifrakturMaguntia", cursive',
      '80px "Orbitron", monospace',
      '80px "Righteous", cursive',
      '80px "Alfa Slab One", cursive',
      '80px "Bungee", cursive',
      '80px "Rubik Wet Paint", cursive'
    ];
    
    // Static font for the rest of the sentence
    const staticFont = '40px "Helvetica Neue", "Arial", sans-serif';

    // Sample full sentence with dynamic "build" word
    function sampleSentence(buildFontSpec){
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Measure "build" in its font
      ctx.font = buildFontSpec;
      const buildWidth = ctx.measureText('build').width;
      const buildHeight = 120;
      
      // Measure rest of sentence in static font
      ctx.font = staticFont;
      const restText = ' the change you wish to see in the world.';
      const restWidth = ctx.measureText(restText).width;
      
      const totalWidth = Math.ceil(buildWidth + restWidth) + 40;
      const height = 160;
      
      canvas.width = totalWidth;
      canvas.height = height;
      
      // Clear canvas
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, totalWidth, height);
      
      // Draw "build" in dynamic font
      ctx.font = buildFontSpec;
      ctx.fillStyle = 'white';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'left';
      ctx.fillText('build', 20, height/2);
      
      // Draw rest of sentence in static font
      ctx.font = staticFont;
      ctx.fillText(restText, 20 + buildWidth, height/2 + 5); // Slight offset for baseline alignment
      
      const imageData = ctx.getImageData(0, 0, totalWidth, height);
      const pixels = [];
      
      const step = 1;
      const scale = 0.12;
      const depthLayers = 4;
      const depthStep = 0.8;
      
      for(let y = 0; y < height; y += step) {
        for(let x = 0; x < totalWidth; x += step) {
          const pixelIndex = (Math.floor(y) * totalWidth + Math.floor(x)) * 4;
          if(imageData.data[pixelIndex] > 128) {
            for(let z = 0; z < depthLayers; z++) {
              pixels.push(
                (x - totalWidth/2) * scale,
                (height/2 - y) * scale,
                (z - 1.5) * depthStep
              );
            }
          }
        }
      }
      
      const out = new Float32Array(maxPoints * 3);
      const textParticleCount = pixels.length / 3;
      
      for (let i = 0; i < maxPoints; i++) {
        const sourceIndex = (i % textParticleCount) * 3;
        out[i * 3] = pixels[sourceIndex];
        out[i * 3 + 1] = pixels[sourceIndex + 1];
        out[i * 3 + 2] = pixels[sourceIndex + 2];
      }
      
      console.log(`Font "${buildFontSpec}": ${textParticleCount} base particles, ${maxPoints} total (${Math.floor(maxPoints/textParticleCount)}x density)`);
      
      return { positions: out, count: textParticleCount };
    }

    // Old sampleText function (keeping for reference, but not used)
    function sampleText(word, fontSpec){
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = fontSpec;
      
      const letterSpacing = 12;
      const letters = [...word];
      const letterWidths = letters.map(letter => ctx.measureText(letter).width);
      const totalLetterWidth = letterWidths.reduce((sum, w) => sum + w, 0);
      const spacingWidth = Math.max(0, letters.length - 1) * letterSpacing;
      const width = Math.ceil(totalLetterWidth + spacingWidth) + 20;
      const height = 120;
      
      canvas.width = width;
      canvas.height = height;
      ctx.font = fontSpec;
      ctx.fillStyle = 'white';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'left';
      
      let cursorX = 10;
      for (let i = 0; i < letters.length; i++) {
        ctx.fillText(letters[i], cursorX, height/2);
        cursorX += letterWidths[i] + letterSpacing;
      }
      
      const imageData = ctx.getImageData(0, 0, width, height);
      const pixels = [];
      
      const step = 1;        // Sample each pixel exactly once
      const scale = 0.12;
      const depthLayers = 4;
      const depthStep = 0.8;  // Space between layers
      
      // Sample with 4 depth layers for 3D effect
      for(let y = 0; y < height; y += step) {
        for(let x = 0; x < width; x += step) {
          const pixelIndex = (Math.floor(y) * width + Math.floor(x)) * 4;
          if(imageData.data[pixelIndex] > 128) {
            for(let z = 0; z < depthLayers; z++) {
              pixels.push(
                (x - width/2) * scale,
                (height/2 - y) * scale,
                (z - 1.5) * depthStep  // Center the layers around z=0
              );
            }
          }
        }
      }
      
      const out = new Float32Array(maxPoints * 3);
      const textParticleCount = pixels.length / 3;
      
      // Always use all maxPoints - distribute across layers for density
      for (let i = 0; i < maxPoints; i++) {
        const sourceIndex = (i % textParticleCount) * 3;
        out[i * 3] = pixels[sourceIndex];
        out[i * 3 + 1] = pixels[sourceIndex + 1];
        out[i * 3 + 2] = pixels[sourceIndex + 2];
      }
      
      console.log(`Font "${fontSpec}": ${textParticleCount} base particles, ${maxPoints} total (${Math.floor(maxPoints/textParticleCount)}x density)`);
      
      return { positions: out, count: textParticleCount };
    }

    // Wait for fonts to load, then build combos
    async function buildCombos(){
      // Wait for all fonts to load
      await document.fonts.ready;
      
      const combos = [];
      for(let i = 0; i < buildFonts.length; i++){
        const fontSpec = buildFonts[i];
        try {
          await document.fonts.load(fontSpec, 'build');
        } catch (err) {
          console.warn(`Failed loading font ${fontSpec}`, err);
          continue;
        }
        
        if (!document.fonts.check(fontSpec, 'build')) {
          console.warn(`Skipping font ${fontSpec} missing glyphs for "build"`);
          continue;
        }

        const { positions, count } = sampleSentence(fontSpec);
        if (!count) {
          console.warn(`Skipping font ${fontSpec} due to zero sampled particles`);
          continue;
        }
        combos.push({pts: positions, surface: solidGold, font: fontSpec});
      }
      
      if (!combos.length) {
        const fallbackFont = '80px "Arial", sans-serif';
        const { positions } = sampleSentence(fallbackFont);
        combos.push({pts: positions, surface: solidGold, font: fallbackFont});
      }

      return combos;
    }
    
    // Initialize after fonts load
    const combos = await buildCombos();

    // Generate explosion vectors once
    for(let i = 0; i < maxPoints; i++){
      dispersedOffsets[i*3] = (Math.random() - 0.5) * 60;
      dispersedOffsets[i*3+1] = (Math.random() - 0.5) * 60;
      dispersedOffsets[i*3+2] = (Math.random() - 0.5) * 60;
    }

    // Initialize with first font
    basePositions.set(combos[0].pts);
    updatePositions(basePositions, dispersedOffsets, 0); // solid state
    
    console.log('Scene children:', scene.children.length);
    console.log('InstancedMesh count:', scene.children.filter(c => c.isInstancedMesh).length);

    // Update positions function
    function updatePositions(center, offset, t){
      for(let i = 0; i < maxPoints; i++){
        const s = i * 3;
        tempPos.set(
          center[s] + offset[s] * t,
          center[s+1] + offset[s+1] * t,
          center[s+2] + offset[s+2] * t
        );
        matrix.identity();  // Reset matrix to identity first
        matrix.setPosition(tempPos);
        instancedMesh.setMatrixAt(i, matrix);
      }
      instancedMesh.instanceMatrix.needsUpdate = true;
    }

    // Morphing functionality - explode then reform
    let morphIndex = 0;
    const morphState = { progress: 0 };
    
    function explodeThenMorph(nextIndex){
      // Kill any existing animation
      if(currentTween) {
        currentTween.kill();
      }
      
      const c = combos[nextIndex];
      targetPositions.set(c.pts);
      
      console.log(`Starting smooth morph to font ${nextIndex}`);
      console.log('Base positions sample:', basePositions[0], basePositions[1], basePositions[2]);
      console.log('Target positions sample:', targetPositions[0], targetPositions[1], targetPositions[2]);
      
      // Reset progress
      morphState.progress = 0;
      
      // Direct smooth transition without explosion
      currentTween = gsap.to(morphState, {
        progress: 1,
        duration: 10,
        ease: "power2.inOut",
        onUpdate: function(){
          const p = morphState.progress;
          // Lerp directly from base to target and update basePositions
          for(let i = 0; i < maxPoints; i++){
            const s = i * 3;
            const newX = THREE.MathUtils.lerp(basePositions[s], targetPositions[s], p);
            const newY = THREE.MathUtils.lerp(basePositions[s+1], targetPositions[s+1], p);
            const newZ = THREE.MathUtils.lerp(basePositions[s+2], targetPositions[s+2], p);
            
            tempPos.set(newX, newY, newZ);
            matrix.setPosition(tempPos);
            instancedMesh.setMatrixAt(i, matrix);
          }
          instancedMesh.instanceMatrix.needsUpdate = true;
        },
        onComplete: function(){
          // Copy final positions to basePositions for next morph
          for(let i = 0; i < maxPoints * 3; i++){
            basePositions[i] = targetPositions[i];
          }
          currentTween = null;
          console.log(`Morph to font ${nextIndex} complete`);
        }
      });
    }

    // Click to morph
    document.addEventListener('click', () => {
      morphIndex = (morphIndex + 1) % combos.length;
      console.log(`Morphing to font ${morphIndex}: ${combos[morphIndex].font}`);
      explodeThenMorph(morphIndex);
    });

    function animate(t){
      // Almost imperceptible rotation to show subtle 3D depth
      instancedMesh.rotation.y = Math.sin(t * 0.0001) * 0.02;  // Super subtle
      instancedMesh.rotation.x = Math.cos(t * 0.00008) * 0.01; // Almost non-existent
      
      // Slow camera pan
      const panSpeed = 0.0001;
      const panX = Math.sin(t * panSpeed) * 25;
      const panY = Math.cos(t * panSpeed * 0.7) * 15;
      
      camera.position.set(panX, panY, 200);
      camera.lookAt(0, 0, 0);
      
      // Render
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
