<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyros</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      font-family: 'Orbitron', 'Helvetica Neue', Arial, sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #links {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: white;
      font-size: 18px;
      z-index: 10;
      white-space: nowrap;
      padding: 0 15px;
      text-shadow: 0 0 8px rgba(0,0,0,0.9);
      font-weight: 500;
    }
    @media (max-width: 768px) {
      #links {
        font-size: 16px;
        bottom: 15px;
        padding: 0 10px;
      }
    }
    @media (max-width: 480px) {
      #links {
        font-size: 14px;
        bottom: 10px;
      }
    }
    #links a {
      color: white;
      text-decoration: none;
      margin: 0 5px;
      text-shadow: 0 0 8px rgba(0,0,0,0.9);
    }
    #links a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="links">
    Kyros investment studio / <a href="mailto:hello@kyros.cc">hello@kyros.cc</a> / <a href="https://calendly.com/reif-kyros/30min" target="_blank">Pitch us</a>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let camera, scene, renderer;
    let textMesh1;
    let earthModel;
    let group;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    let bubbles = [];
    let mouseX = 0;
    let mouseY = 0;
    let pointerX = 0, pointerY = 0;
    let pointerXOnPointerDown = 0, pointerYOnPointerDown = 0;
    let targetRotationX = 0, targetRotationY = 0;
    let targetRotationXOnPointerDown = 0, targetRotationYOnPointerDown = 0;
    let isPointerDown = false;
    let isMobile = window.innerWidth < 768;
    let isSmallMobile = window.innerWidth < 480;
    let orbitTime = 0;

    function updateResponsiveFlags() {
      isMobile = window.innerWidth < 768;
      isSmallMobile = window.innerWidth < 480;
    }

    function init() {
      console.log('üöÄ Starting Three.js initialization...');
      document.title = 'Kyros - Initializing';
      
      // Camera positioned to see entire Earth and orbiting text
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000); // Wider FOV
      camera.position.set(0, 0, 30);  // Even further back to see full scene
      console.log('‚úÖ Camera created');

      // Scene with realistic deep space background
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000); // Deep black space background
      scene.fog = new THREE.FogExp2(0x000000, 0.0005); // Very subtle fog for depth
      console.log('‚úÖ Scene created with realistic space background');
      
      // Load space HDR environment map
      new RGBELoader().load('https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/space_1k.exr', (hdr) => {
        hdr.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = hdr;
        console.log('‚úÖ Space HDR environment map loaded');
      }, undefined, function(error) {
        console.log('‚ö†Ô∏è Space HDR load failed, using fallback:', error);
      });

      // Add warm ambient lighting
      scene.add(new THREE.AmbientLight(0x404040, 0.2)); // Dim ambient light
      
      // Add warm yellow sun-like directional light with shadows (behind camera)
      const sunLight = new THREE.DirectionalLight(0xffff88, 2.0); // Pure yellow sun (no green)
      sunLight.position.set(0, 0, 30); // Behind the camera, illuminating the scene
      sunLight.target.position.set(0, 0, 0); // Point at the Earth
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      sunLight.shadow.camera.near = 0.5;
      sunLight.shadow.camera.far = 50;
      sunLight.shadow.camera.left = -20;
      sunLight.shadow.camera.right = 20;
      sunLight.shadow.camera.top = 20;
      sunLight.shadow.camera.bottom = -20;
      scene.add(sunLight);
      scene.add(sunLight.target); // Add target to scene
      
      console.log('‚úÖ Added space lighting');

      // Renderer (must be created first)
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Set up animation loop
      renderer.setAnimationLoop(animate);

      // No dynamic lighting for performance


      // Create orbital system - parent group rotates around Earth
      group = new THREE.Group();
      group.position.set(0, 0, 0);
      scene.add(group);

      updateResponsiveFlags();

      // Create simple starfield background
      createStarfield();
      console.log('‚úÖ Starfield created');

      // Load Earth model and create text
      loadEarth();
      createText();

      // Events
      document.addEventListener('pointerdown', onPointerDown);
      document.addEventListener('mousemove', onMouseMove);
      window.addEventListener('resize', onWindowResize);
    }
    
    function onMouseMove(event) {
      mouseX = (event.clientX - windowHalfX) / 100;
      mouseY = (event.clientY - windowHalfY) / 100;
    }

    function createText() {
      console.log('üìù Creating 3D bubble text with realistic physics...');
      if (textMesh1) group.remove(textMesh1);

      // Load font and create bubble text
      const loader = new FontLoader();
      // Try to load local Orbitron font (Bank Gothic lookalike) - fallback to Helvetiker
      loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        
        // Create text geometry with more depth
        const textGeometry = new TextGeometry('build the change you wish to see in the world', {
          font: font,
          size: isMobile ? 0.6 : 0.8,
          height: 0.8,              // Increased depth for 3D effect
          curveSegments: 16,
          bevelEnabled: true,
          bevelThickness: 0.15,     // More pronounced bevel
          bevelSize: 0.08,          // Larger bevel
          bevelSegments: 8          // Smoother bevel
        });
        
        textGeometry.computeBoundingBox();
        textGeometry.center();
        
        // Calculate Earth circumference from actual loaded model
        let earthRadius = 2; // Default fallback
        let textOrbitRadius = 8; // Default fallback
        
        if (earthModel) {
          // Get actual Earth bounding box
          earthModel.updateMatrixWorld();
          const boundingBox = new THREE.Box3().setFromObject(earthModel);
          const size = boundingBox.getSize(new THREE.Vector3());
          earthRadius = Math.max(size.x, size.y, size.z) / 2;
          
          // Calculate circumference and set text orbit radius with clear offset
          const earthCircumference = 2 * Math.PI * earthRadius;
          textOrbitRadius = earthRadius + (earthCircumference * 0.25); // 25% of circumference above Earth for clear visibility
          
          console.log('üåç Earth radius calculated:', earthRadius);
          console.log('üåç Earth circumference:', earthCircumference);
          console.log('üåç Text orbit radius:', textOrbitRadius);
        } else {
          console.log('‚ö†Ô∏è Earth model not loaded yet, using default radius');
          // Use larger default orbit for better visibility
          textOrbitRadius = 12;
        }
        
        // Bend text geometry to curve around Earth like Universal Studios (facing outward)
        const pos = textGeometry.attributes.position;
        for (let i = 0; i < pos.count; i++) {
          const x = pos.getX(i);
          const y = pos.getY(i);
          const angle = x / textOrbitRadius;
          const newX = Math.sin(angle) * textOrbitRadius;
          const newZ = Math.cos(angle) * textOrbitRadius; // Remove negative offset - wrap outside
          pos.setX(i, newX);
          pos.setZ(i, newZ);
        }
        pos.needsUpdate = true;
        textGeometry.computeVertexNormals();

        // Create Universal Studios-style metallic gold material with maximum reflections
        const textMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xffd700,        // Gold color
          metalness: 1.0,         // Maximum metalness
          roughness: 0.0,         // Mirror-like surface
          clearcoat: 1.0,
          clearcoatRoughness: 0.0,
          envMapIntensity: 5.0,   // Maximum environment reflections
          emissive: 0x332200,     // Subtle gold glow
          emissiveIntensity: 0.3
        });

        // Create the mesh
        textMesh1 = new THREE.Mesh(textGeometry, textMaterial);
        
        // Position curved text at Earth's center level (same as Earth)
        textMesh1.position.set(0, 0, 0);
        
        // Make text face outward from Earth
        textMesh1.rotation.y = Math.PI;
        
        // Add curved text to orbital group
        group.add(textMesh1);
        console.log('‚úÖ 3D bubble text created with realistic physics');
      }, undefined, function(error) {
        console.log('‚ö†Ô∏è Font load failed, using fallback text:', error);
        createFallbackText();
      });
    }

    function createFallbackText() {
      // Fallback canvas text if font fails
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = isMobile ? 800 : 1200;
      canvas.height = isMobile ? 200 : 300;
      
      const fontSize = isMobile ? 20 : 28;
      const lineHeight = fontSize * 1.3;
      
      ctx.font = `bold ${fontSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#9fd6ff';
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      ctx.fillText('build the change you wish to see', centerX, centerY - lineHeight/2);
      ctx.fillText('in the world', centerX, centerY + lineHeight/2);
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      
      const planeWidth = isMobile ? 16 : 24;
      const planeHeight = isMobile ? 5 : 7;
      
      textMesh1 = new THREE.Mesh(new THREE.PlaneGeometry(planeWidth, planeHeight), material);
      textMesh1.position.set(0, 0, 0);
      textMesh1.rotation.y = Math.PI;
      group.add(textMesh1);
      console.log('‚úÖ Fallback text created');
    }

    function loadEarth() {
      console.log('üåç Loading Earth model...');
      const loader = new GLTFLoader();
      
      // Try GLB first
      console.log('üîç Attempting to load earth.glb...');
      loader.load('earth.glb', function(gltf) {
        console.log('‚úÖ Earth GLB loaded successfully');
        earthModel = gltf.scene;
        
        // Keep original materials from GLTF - don't override them
        earthModel.scale.setScalar(2);
        earthModel.position.set(0, 0, 0);
        
        // Add Earth directly to scene (not in rotating group)
        scene.add(earthModel);
        console.log('‚úÖ Earth GLB model loaded with original materials');
      }, function(progress) {
        console.log('üìä GLB loading progress:', (progress.loaded / progress.total * 100) + '%');
      }, function(error) {
        console.log('‚ö†Ô∏è Earth GLB load failed:', error);
        
        // Reset loader path and try GLTF
        loader.setPath('earth_gltf/');
        console.log('üîç Attempting to load GLTF from earth_gltf/scene.gltf...');
        loader.load('scene.gltf', function(gltf) {
          console.log('‚úÖ Earth GLTF loaded successfully');
          earthModel = gltf.scene;
          
          // Keep original materials from GLTF - don't override them
          earthModel.scale.setScalar(2);
          earthModel.position.set(0, 0, 0);
          
          // Add Earth directly to scene (not in rotating group)
          scene.add(earthModel);
          console.log('‚úÖ Earth GLTF model loaded with original materials');
        }, function(progress) {
          console.log('üìä GLTF loading progress:', (progress.loaded / progress.total * 100) + '%');
        }, function(error2) {
          console.log('‚ö†Ô∏è Earth GLTF also failed:', error2);
          console.log('‚ùå No Earth model could be loaded');
        });
      });
    }


    function createStarfield() {
      // Create realistic starfield background
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const starPositions = new Float32Array(starCount * 3);
      const starColors = new Float32Array(starCount * 3);
      const starSizes = new Float32Array(starCount);
      
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        
        // Random positions in a sphere
        const radius = Math.random() * 1000 + 500;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        
        starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        starPositions[i3 + 2] = radius * Math.cos(phi);
        
        // Varied star colors (mostly white/blue, some yellow/red)
        const colorVariation = Math.random();
        if (colorVariation < 0.7) {
          // White/blue stars
          starColors[i3] = 0.9 + Math.random() * 0.1;
          starColors[i3 + 1] = 0.9 + Math.random() * 0.1;
          starColors[i3 + 2] = 1.0;
        } else if (colorVariation < 0.9) {
          // Yellow stars
          starColors[i3] = 1.0;
          starColors[i3 + 1] = 0.8 + Math.random() * 0.2;
          starColors[i3 + 2] = 0.6 + Math.random() * 0.2;
        } else {
          // Red stars
          starColors[i3] = 1.0;
          starColors[i3 + 1] = 0.6 + Math.random() * 0.2;
          starColors[i3 + 2] = 0.4 + Math.random() * 0.2;
        }
        
        // Varied star sizes
        starSizes[i] = Math.random() * 3 + 1;
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
      starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
      
      const starMaterial = new THREE.PointsMaterial({
        size: 1,
        transparent: true,
        opacity: 0.9,
        vertexColors: true,
        sizeAttenuation: false,
        alphaTest: 0.1
      });
      
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
      console.log('‚úÖ Realistic starfield created with', starCount, 'varied stars');
    }


    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      updateResponsiveFlags();
      
      // Recreate text with responsive sizing
      createText();
      console.log('üéâ Three.js initialization complete!');
    }

    // Initialize after DOM is ready
    init();

    function onPointerDown(event) {
      if (event.isPrimary === false) return;
      isPointerDown = true;
      pointerXOnPointerDown = event.clientX - windowHalfX;
      pointerYOnPointerDown = event.clientY - windowHalfY;
      targetRotationXOnPointerDown = targetRotationX;
      targetRotationYOnPointerDown = targetRotationY;
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerup', onPointerUp);
    }

    function onPointerMove(event) {
      if (event.isPrimary === false) return;
      pointerX = event.clientX - windowHalfX;
      pointerY = event.clientY - windowHalfY;
      targetRotationY = targetRotationYOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
      targetRotationX = targetRotationXOnPointerDown + (pointerY - pointerYOnPointerDown) * 0.02;
      
      // Clamp rotations to keep text readable - tighter range for better bubble density
      targetRotationY = Math.max(-Math.PI / 6, Math.min(Math.PI / 6, targetRotationY)); // ¬±30¬∞
      targetRotationX = Math.max(-Math.PI / 8, Math.min(Math.PI / 8, targetRotationX)); // ¬±22.5¬∞
    }

    function onPointerUp(event) {
      if (event.isPrimary === false) return;
      isPointerDown = false;
      document.removeEventListener('pointermove', onPointerMove);
      document.removeEventListener('pointerup', onPointerUp);
    }

    function animate(t) {
      // Only log once to avoid spam
      if (!animate.logged) {
        console.log('üé¨ Animation loop started');
        animate.logged = true;
      }
      
      const time = (t || 0) * 0.0001;
      
      // Orbital animation - rotate the entire group around Y-axis (like Universal Studios)
      group.rotation.y -= 0.003; // Reverse direction so text reads right to left
      
      // Earth stays stationary - no rotation
      
      // Curved text doesn't need to face camera - it's already oriented outward
      
      // Click-to-pan camera controls (only when pointer is down)
      let targetX = 0, targetY = 0;
      if (isPointerDown) {
        targetX = -mouseX * 0.8;  // Reduced sensitivity
        targetY = mouseY * 0.8;   // Reduced sensitivity
      }
      
      // Smooth camera movement around the orbital system
      camera.position.x += (targetX - camera.position.x) * 0.08;
      camera.position.y += (targetY - camera.position.y) * 0.08;
      camera.position.z = 30; // Keep camera far back to see entire Earth and text orbit
      
      // Always look at the orbital center
      camera.lookAt(0, 0, 0);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
