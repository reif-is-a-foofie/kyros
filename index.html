<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyros</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'Universal Secondary Web';
      src: url('universal-secondary-web-regular.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      font-family: 'Orbitron', 'Helvetica Neue', Arial, sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #links {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #ffd700; /* Gold color matching orbiting text */
      font-size: 36px;
      font-family: 'Universal Secondary Web', 'Helvetica', 'Arial', sans-serif;
      z-index: 10;
      white-space: nowrap;
      padding: 0 15px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4); /* Gold glow */
      font-weight: 600;
      background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700); /* Gold gradient */
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: shimmer 3s ease-in-out infinite alternate;
    }
    
    @keyframes shimmer {
      0% { filter: brightness(1) saturate(1); }
      100% { filter: brightness(1.2) saturate(1.3); }
    }
    @media (max-width: 768px) {
      #links {
        font-size: 32px;
        bottom: 15px;
        padding: 0 10px;
      }
    }
    @media (max-width: 480px) {
      #links {
        font-size: 28px;
        bottom: 10px;
      }
    }
    #links a {
      color: #ffd700; /* Gold color matching orbiting text */
      text-decoration: none;
      margin: 0 5px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4); /* Gold glow */
      background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700); /* Gold gradient */
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      transition: all 0.3s ease;
    }
    #links a:hover {
      filter: brightness(1.3) saturate(1.5);
      text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 60px rgba(255, 215, 0, 0.6);
    }
    
    /* Military LED Screen Banner */
    #military-banner {
      position: fixed;
      bottom: 20px;
      left: 24px;
      font-family: 'Share Tech Mono', 'Courier New', monospace;
      font-size: 30.6px; /* 15% smaller than 36px */
      color: #ffd700;
      text-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
    }
    
    #military-banner.show {
      opacity: 1;
    }
    
    #military-banner .cursor {
      animation: blink 1s infinite;
      color: #ffd700;
    }

    #military-banner.clickable {
      text-decoration: underline;
      text-decoration-color: #ffd700;
      text-underline-offset: 4px;
      cursor: pointer;
    }
    
    #loading-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(10, 15, 25, 0.95), rgba(2, 4, 8, 0.98));
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 2000;
      transition: opacity 0.6s ease, visibility 0.6s ease;
    }

    #loading-overlay.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .loading-inner {
      text-align: center;
      color: #ffd700;
      font-family: 'Share Tech Mono', 'Courier New', monospace;
      text-transform: uppercase;
      letter-spacing: 0.3rem;
    }

    .loading-title {
      font-size: clamp(32px, 6vw, 64px);
      margin-bottom: 20px;
    }

    .loading-status {
      font-size: clamp(18px, 4vw, 28px);
      opacity: 0.85;
    }
    
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    
    #military-banner .glitch {
      position: relative;
      display: inline-block;
    }
    
    #military-banner .glitch::before,
    #military-banner .glitch::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    #military-banner .glitch::before {
      animation: glitch-1 0.3s infinite;
      color: #ff0000;
      z-index: -1;
    }
    
    #military-banner .glitch::after {
      animation: glitch-2 0.3s infinite;
      color: #0000ff;
      z-index: -2;
    }
    
    @keyframes glitch-1 {
      0%, 100% { transform: translate(0); }
      20% { transform: translate(-2px, 2px); }
      40% { transform: translate(-2px, -2px); }
      60% { transform: translate(2px, 2px); }
      80% { transform: translate(2px, -2px); }
    }
    
    @keyframes glitch-2 {
      0%, 100% { transform: translate(0); }
      20% { transform: translate(2px, 2px); }
      40% { transform: translate(2px, -2px); }
      60% { transform: translate(-2px, 2px); }
      80% { transform: translate(-2px, -2px); }
    }
    
  </style>
</head>
<body>
  <!-- Military LED Banner (replaces bottom links) -->
  <div id="military-banner">
    <span id="banner-content"></span><span class="cursor">_</span>
  </div>

  <div id="loading-overlay">
    <div class="loading-inner">
      <div class="loading-title">KYROS</div>
      <div class="loading-status" id="loading-status-text">INITIALIZING...</div>
    </div>
  </div>

  <!-- Hidden links for clickable functionality -->
  <div id="links" style="display: none;">
    Kyros investment studio / <a href="mailto:hello@kyros.cc">hello@kyros.cc</a> / <a href="https://calendly.com/reif-kyros/30min" target="_blank">Pitch us</a>
  </div>


  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let camera, scene, renderer;
    let textMesh1;
    let earthModel;
    let group;
    let textOrbitRadius = 12;
    let earthRadius = 0;
    let sunLight;
    let orbitSpeed = 0.004; // Reduced for performance
    let earthRotationSpeed = 0.00025; // Extremely slow, subtle Earth rotation (half speed)
    let originalTextPositions = null; // Store original flat text positions
    
    // Multiple orbital objects
    let orbitalObjects = [];
    let orbitalGroups = [];
    let glbFiles = [
      'pizza/scene.gltf',
      'orbital_objects/crystal_stone_rock.glb', 
      'orbital_objects/gameboy_classic.glb', 
      'orbital_objects/2f322dab13694f6db1fb4795ff209171.glb',
      'orbital_objects/tether_usdt.glb'
    ]; // Orbital objects around Earth - ordered: pizza (GLTF) ‚Üí crystal ‚Üí gameboy ‚Üí K ‚Üí tether
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    let bubbles = [];
    let mouseX = 0;
    let mouseY = 0;
    let pointerX = 0, pointerY = 0;
    let pointerXOnPointerDown = 0, pointerYOnPointerDown = 0;
    let targetRotationX = 0, targetRotationY = 0;
    let targetRotationXOnPointerDown = 0, targetRotationYOnPointerDown = 0;
    let isPointerDown = false;
    let isMobile = window.innerWidth < 768;
    let isSmallMobile = window.innerWidth < 480;
    let orbitAccumulator = 0;
    let groupTiltX = 0;
    let groupYawOffset = 0;
    let orbitCycleTracker = 0;
    let completedOrbitCycles = 0;
    let nextOrbitalIndex = 0;
    let cachedFont = null;
    let textMaterial = null;
    
    // Earth panning controls
    let earthPanX = 0;
    let earthPanY = 0;
    let earthPanZ = 0;
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;
    let panSensitivity = 0.5;
    
    // Message queue system
    let messageQueue = [];
    let isMessageShowing = false;
    let messageTimeout = null;

    function updateResponsiveFlags() {
      isMobile = window.innerWidth < 768;
      isSmallMobile = window.innerWidth < 480;
    }

    const loadingState = {
      totalSteps: 3, // Star map, Earth, Text (font loading is part of text)
      completedSteps: 0,
      finished: false
    };
    
    // Emergency timeout - if loading takes more than 10 seconds, force completion
    setTimeout(() => {
      if (!loadingState.finished) {
        console.log('üö® Emergency timeout - forcing loading completion after 10 seconds');
        finishLoadingSequence();
      }
    }, 10000);

    const loadingFlags = {
      hdr: false,
      earth: false,
      font: false,
      text: false
    };

    function repaintScene() {
      if (!renderer || !scene || !camera) return;
      renderer.render(scene, camera);
    }

    function setLoadingStatus(message) {
      const overlayStatus = document.getElementById('loading-status-text');
      if (overlayStatus) {
        overlayStatus.textContent = message;
      }
      const banner = document.getElementById('military-banner');
      const content = document.getElementById('banner-content');
      if (banner && content) {
        banner.classList.add('show');
        content.textContent = message;
      }
    }

    function markLoadingStep(label) {
      if (loadingState.finished) return;
      loadingState.completedSteps = Math.min(loadingState.completedSteps + 1, loadingState.totalSteps);
      const message = `INITIALIZING... ${loadingState.completedSteps}/${loadingState.totalSteps} ‚Äì ${label}`;
      setLoadingStatus(message);
      if (loadingState.completedSteps >= loadingState.totalSteps) {
        finishLoadingSequence();
      }
    }

    function finishLoadingSequence() {
      if (loadingState.finished) return;
      loadingState.finished = true;
      setLoadingStatus('SYSTEMS ONLINE ‚Äì WELCOME TO KYROS');
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        setTimeout(() => {
          overlay.classList.add('hidden');
        }, 700);
      }
      setTimeout(() => {
        const banner = document.getElementById('military-banner');
        const content = document.getElementById('banner-content');
        if (banner) banner.classList.remove('show');
        if (content) content.textContent = '';
        startMilitaryBanner();
      }, 1800);
    }

    function addMessageToQueue(message) {
      messageQueue.push(message);
      processMessageQueue();
    }
    
    function processMessageQueue() {
      if (isMessageShowing || messageQueue.length === 0) return;
      
      isMessageShowing = true;
      const message = messageQueue.shift();
      showMessage(message);
    }
    
    function showMessage(message) {
      const banner = document.getElementById('military-banner');
      const content = document.getElementById('banner-content');
      
      if (!banner || !content) return;
      
      // Show the banner
      banner.classList.add('show');
      
      // Type out the message
      content.textContent = '';
      
      let charIndex = 0;
      function typeChar() {
        if (charIndex < message.length) {
          content.textContent += message[charIndex];
          charIndex++;
          setTimeout(typeChar, 30); // Faster typing for announcements
        } else {
          // Hide after 10 seconds, then wait 2 seconds before next message
          messageTimeout = setTimeout(() => {
            banner.classList.remove('show');
            setTimeout(() => {
              isMessageShowing = false;
              processMessageQueue(); // Process next message in queue
            }, 2000); // 2 second pause between messages
          }, 10000);
        }
      }
      
      typeChar();
      console.log(`üöÄ ${message}`);
    }
    
    function showBottomTextForOrbitalObject(objectIndex) {
      const announcements = [
        'PIZZA ENTERED ORBIT',
        'CRYSTAL STONE ENTERED ORBIT', 
        'GAME BOY CLASSIC ENTERED ORBIT',
        'K OBJECT ENTERED ORBIT',
        'TETHER USDT ENTERED ORBIT'
      ];
      
      const message = announcements[objectIndex] || `OBJECT ${objectIndex + 1} ENTERED ORBIT`;
      addMessageToQueue(message);
    }

    function init() {
      console.log('üöÄ Starting Three.js initialization...');
      document.title = 'Kyros - Initializing';
      
      setLoadingStatus(`INITIALIZING... 0/${loadingState.totalSteps} ‚Äì STARTING SYSTEMS`);
      
      // Camera positioned to see entire Earth and orbiting text
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000); // Wider FOV
      
      // Dynamic camera position based on screen size
      const screenArea = window.innerWidth * window.innerHeight;
      const baseCameraZ = 28; // Base camera distance
      let cameraZ = baseCameraZ;
      
      if (screenArea < 800000) { // Small screens (mobile)
        cameraZ = baseCameraZ * 0.8; // Closer camera
      } else if (screenArea > 2000000) { // Large screens
        cameraZ = baseCameraZ * 1.2; // Further camera
      }
      
      camera.position.set(0, 0, cameraZ);
      console.log('üì± Dynamic camera position set to z:', cameraZ, 'based on screen area:', screenArea);
      console.log('‚úÖ Camera created');

      // Scene with realistic deep space background
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x05060a); // Deep black with subtle blue tint
      scene.fog = new THREE.FogExp2(0x05060a, 0.00018); // Gentle haze to lift the blacks slightly
      console.log('‚úÖ Scene created with realistic space background');

      // Create custom star map environment using existing starfield
      // Starfield is created below after renderer initialization
      if (!loadingFlags.hdr) {
        loadingFlags.hdr = true;
        markLoadingStep('Star map ready');
      }

      // Optimized 4-light setup with boosted intensity for performance while maintaining cinematic quality
      
      // 1. Key sunlight - main directional light (boosted intensity)
      const sunLight = new THREE.DirectionalLight(0xffffff, 8); // Increased from 3 to 8
      sunLight.position.set(15, 12, 10);
      sunLight.target.position.set(0, 0, 0);
      sunLight.castShadow = false; // Disabled for performance
      scene.add(sunLight);
      scene.add(sunLight.target);
      
      // 2. Ambient light for overall illumination (boosted)
      scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // Increased from 0.15 to 0.4
      
      // 3. Rim light for edge definition (boosted)
      const rimLight = new THREE.DirectionalLight(0xd4e5ff, 6); // Increased from 2.5 to 6
      rimLight.position.set(-6, -2, 14);
      scene.add(rimLight);
      
      // 4. Text-specific light for readability (boosted)
      const textLight = new THREE.PointLight(0xfff8e7, 5, 30, 2); // Increased from 2 to 5, range from 25 to 30
      textLight.position.set(0, 0, 15);
      scene.add(textLight);
      
      console.log('‚úÖ Added optimized 4-light setup with boosted intensity for performance');

      // Renderer (must be created first) - optimized for performance
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); // Clamped to 1 for performance
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true; // Enabled for text shadows
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
      renderer.physicallyCorrectLights = true;
      
      // Optimized color and tone mapping
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0; // Reduced for performance
      
      document.body.appendChild(renderer.domElement);

      // No pizza-specific global fixes - using original materials from GLB

      // Set up animation loop
      renderer.setAnimationLoop(animate);
      repaintScene();

      // No dynamic lighting for performance


      // Create orbital system - parent group rotates around Earth
      group = new THREE.Group();
      group.position.set(0, 0, 0);
      scene.add(group);

      updateResponsiveFlags();

      // Create simple starfield background
      createStarfield();
      console.log('‚úÖ Starfield created');

      // Load Earth model (text will be created after Earth loads)
      loadEarth();
      // createText(); // Removed - text creation now happens in loadEarth() after model loads

      // Events
      document.addEventListener('pointerdown', onPointerDown);
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerup', onPointerUp);
      window.addEventListener('resize', onWindowResize);
      
      // Handle screen orientation change for mobile devices
      window.addEventListener('orientationchange', function() {
        setTimeout(onWindowResize, 100); // Small delay to ensure dimensions are updated
      }, false);
    }
    
    function onMouseMove(event) {
      // Mouse tracking removed - no longer needed for parallax
    }

    function createText() {
      console.log('üìù Creating 3D bubble text with realistic physics...');
      if (textMesh1) group.remove(textMesh1);

      // Add timeout fallback to prevent infinite loading
      let fontLoaded = false;
      const fontTimeout = setTimeout(() => {
        if (!fontLoaded) {
          console.log('‚ö†Ô∏è Font loading timeout - make sure you are running a web server (not opening file:// directly)');
          console.log('‚ö†Ô∏è Using fallback text');
          createFallbackText();
          if (!loadingFlags.text) {
            loadingFlags.text = true;
            markLoadingStep('Text ready (timeout fallback)');
          }
        }
      }, 2000); // 2 second timeout

      // Load font and create bubble text
      const loader = new FontLoader();
    // Load Universal Secondaries font (authentic Universal Studios look)
    console.log('üî§ Loading Universal font...');
    loader.load('Universal Secondary Web_Regular.json', function(font) {
      fontLoaded = true;
      clearTimeout(fontTimeout);
      console.log('‚úÖ Universal font loaded successfully');
      
      // Create single line of text
      createSingleLineText(font);
      if (!loadingFlags.text) {
        loadingFlags.text = true;
        markLoadingStep('Text ready');
      }
      
      // Bottom text font is now handled directly in CSS
    }, undefined, function(error) {
      fontLoaded = true;
      clearTimeout(fontTimeout);
      console.log('‚ö†Ô∏è Font load failed, using fallback text:', error);
      createFallbackText();
      if (!loadingFlags.text) {
        loadingFlags.text = true;
        markLoadingStep('Text ready (fallback)');
      }
    });
    }

    function bendTextGeometry(geometry, radius, yOffset) {
      const pos = geometry.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const angle = x / radius;
        const newX = Math.sin(angle) * radius;
        const newZ = Math.cos(angle) * radius;
        pos.setX(i, newX);
        pos.setY(i, y + yOffset); // Add vertical offset for line separation
        pos.setZ(i, newZ);
      }
      pos.needsUpdate = true;
      geometry.computeVertexNormals();
    }

    function ensureEarthShadowSettings() {
      if (!earthModel) return;
      earthModel.traverse((child) => {
        if (!child.isMesh) return;
        child.castShadow = false; // Disabled for performance
        child.receiveShadow = false; // Disabled for performance
        if (child.material) {
          child.material.needsUpdate = true;
        }
      });
      repaintScene();
    }

    function createSingleLineText(font) {
      const text = "build the change you wish to see in the world.";
      
        // Create clean Universal Studios-style text geometry with more depth
        const textGeometry = new TextGeometry(text, {
          font: font,
          size: isMobile ? 0.5 : 0.8,    // Smaller text for tighter orbit
          depth: 0.6,                    // Reduced depth for tighter fit
          curveSegments: 16,             // Fewer segments for tighter curve
          letterSpacing: -0.15,          // Tighter letter spacing for better readability
          bevelEnabled: true,            // Subtle bevels
          bevelThickness: 0.08,          // Thinner bevels
          bevelSize: 0.04,               // Smaller bevels
          bevelSegments: 6               // Fewer bevel segments
        });
      
      textGeometry.computeBoundingBox();
      textGeometry.center();
      textGeometry.computeBoundingBox();
      
      const boundingBox = textGeometry.boundingBox;
      const halfTextWidth = boundingBox ? Math.max(Math.abs(boundingBox.min.x), Math.abs(boundingBox.max.x)) : 0;
      // Calculate Earth circumference from actual loaded model
      let earthRadius = 2; // Default fallback
      // No minimum radius constraints - use exact formula specified
      
      if (earthModel) {
        // Get actual Earth bounding box
        earthModel.updateMatrixWorld();
        const boundingBox = new THREE.Box3().setFromObject(earthModel);
        const size = boundingBox.getSize(new THREE.Vector3());
        earthRadius = Math.max(size.x, size.y, size.z) / 2;
        
        console.log('üåçüåçüåç EARTH RADIUS:', earthRadius);
        console.log('üåç Earth bounding box size:', size);
        
        // Position text so front face sits exactly at Earth surface
        // Account for bend curvature - text extends further out due to curvature
        const textDepth = 0.6; // Must match depth in TextGeometry  
        const bendOffset = 1.5; // Increased for tighter curve compression
        textOrbitRadius = earthRadius - textDepth - bendOffset; // Subtract depth and bend offset
        console.log('üéØ Text orbit radius (center):', textOrbitRadius.toFixed(2), '(tighter curve for better compression)');
        
        console.log('üåç Earth radius calculated:', earthRadius);
        console.log('üåç Text orbit radius:', textOrbitRadius);
        console.log('üåç Camera position:', camera ? camera.position : 'Camera not ready');
        console.log('üåç Text will orbit at distance:', textOrbitRadius, 'from Earth center');
        } else {
          console.log('‚ö†Ô∏è Earth model not loaded yet, using default radius');
          earthRadius = 2; // Fallback radius
          // Position text so front face sits exactly at Earth surface
          const textDepth = 0.6;
          const bendOffset = 1.5; // Increased for tighter curve compression
          textOrbitRadius = earthRadius - textDepth - bendOffset;
          console.log('üéØ Fallback text orbit radius (center):', textOrbitRadius.toFixed(2), '(tighter curve)');
        }
        
      // Persist orbit radius globally for other systems
      window.textOrbitRadius = textOrbitRadius;
      
      // Store earthRadius globally for rebending function
      window.earthRadius = earthRadius;
      
      // Store original flat positions for rebending (for both lines)
      const pos = textGeometry.attributes.position;
      originalTextPositions = new Float32Array(pos.array.length);
      originalTextPositions.set(pos.array, 0);
      window.textGeometry = textGeometry;
      
      // Bend text geometry to curve around Earth (facing outward)
      console.log('üéØüéØüéØ BENDING TEXT WITH ORBIT RADIUS:', textOrbitRadius);
      console.log('üéØ Text will be positioned at radius:', textOrbitRadius);
      console.log('üéØ Earth radius for reference:', earthRadius);
      console.log('üéØ Expected text front face distance from center:', textOrbitRadius + 0.3);
      bendTextGeometry(textGeometry, textOrbitRadius, 0); // Single line centered

      // Spectacular gold material with maximum shine and depth
      const textMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffd700,        // Rich gold base color
        metalness: 0.95,        // Near-perfect metalness for gold
        roughness: 0.05,        // Mirror-like smoothness
        clearcoat: 1.0,         // Maximum clearcoat for extra shine
        clearcoatRoughness: 0.0, // Perfect clearcoat smoothness
        envMapIntensity: 4.0,   // Extra strong environment reflections
        emissive: 0x332200,     // Warm gold interior glow
        emissiveIntensity: 0.8, // Strong but not overpowering glow
        reflectivity: 1.0,      // Maximum reflectivity
        sheen: 0.8,             // High sheen for luster
        sheenRoughness: 0.1,    // Smooth sheen
        side: THREE.DoubleSide, // Ensure both sides are rendered
        transparent: false,     // Ensure no transparency issues
        opacity: 1.0           // Fully opaque
      });

        // Create single text mesh
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        
        // Enable shadow casting for dramatic effect
        textMesh.castShadow = true;
        textMesh.receiveShadow = false;
        
        // Debug: Log text positioning info
        console.log('üéØ Headline text debug info:');
        console.log('  - Text orbit radius:', textOrbitRadius.toFixed(2));
        console.log('  - Earth radius:', earthRadius.toFixed(2));
        console.log('  - Text position:', textMesh.position);
        console.log('  - Text scale:', textMesh.scale);
        console.log('  - Text material color:', textMaterial.color.getHexString());
        console.log('  - Text material metalness:', textMaterial.metalness);
        
        // Text positioning is now handled by the simplified system above
        
        // Make text face outward from Earth
        textMesh.rotation.y = Math.PI;
        
        // Add Universal Studios-style orbit tilt
        group.rotation.x = Math.PI / 8;  // Slight X-axis tilt
        group.rotation.z = Math.PI / 12; // Slight Z-axis tilt
        
        // Add curved text to orbital group
        group.add(textMesh);
        
        // Store reference to text mesh
        window.textMesh1 = textMesh;
        window.textMesh2 = textMesh; // Keep for compatibility
        
        // Keep text orbit flat (no tilt) - aligned with Earth's equator
        group.rotation.x = 0; // No tilt on X-axis
        group.rotation.z = 0; // No tilt on Z-axis
        
        console.log('üéØ Text orbit flat - aligned with Earth equator');
        
        // Store reference to original material for protection
        textMesh.userData.originalMaterial = textMaterial.clone();
        
        // Enable shadows for Earth model
        ensureEarthShadowSettings();
        
        repaintScene();
        console.log('‚úÖ 3D bubble text created with realistic physics');
        console.log('‚úÖ Text mesh added to scene at position:', textMesh.position);
        console.log('‚úÖ Scene now contains', scene.children.length, 'objects');
      
      // Start material protection loop
      startMaterialProtection();
      
      // Dynamic text rebending disabled - using fixed orbit radius
      // startDynamicTextRebending();
      
      // Window resize handler disabled - using fixed orbit radius
      // window.addEventListener('resize', handleWindowResize);
      
      // Load textures and other assets
      
      // Start introducing orbital objects one by one
      startOrbitalSequence();
    }


    function rebendTextGeometry() {
      if (!textMesh1 || !originalTextPositions) {
        console.log('‚ùå Cannot rebend: missing textMesh1 or originalTextPositions');
        return;
      }
      
      // No arc minimum radius constraint - use exact orbit radius
      window.textOrbitRadius = textOrbitRadius;
      
      console.log('üîÑ Rebending text geometry with radius:', textOrbitRadius);
      
      const geometry = textMesh1.geometry;
      const pos = geometry.attributes.position;
      
      // Reset to original flat positions
      pos.array.set(originalTextPositions);
      
      // Now rebend with new radius
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const angle = x / textOrbitRadius;
        const newX = Math.sin(angle) * textOrbitRadius;
        const newZ = Math.cos(angle) * textOrbitRadius;
        pos.setX(i, newX);
        pos.setZ(i, newZ);
      }
      
      pos.needsUpdate = true;
      geometry.computeVertexNormals();
      
      console.log('‚úÖ Text geometry rebent successfully');
    }

    // Calculate dynamic orbit radius based on screen size and camera position
    function calculateDynamicOrbitRadius() {
      const earthRadius = window.earthRadius || 1;
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const aspectRatio = screenWidth / screenHeight;
      
      // Base radius calculation considering screen size - tight but visible orbit
      let baseRadius = earthRadius * 1.4; // Tight but visible orbit

      // Adjust for screen aspect ratio
      if (aspectRatio > 1.5) { // Wide screens
        baseRadius *= 0.8; // Closer orbit for wide screens
      } else if (aspectRatio < 0.8) { // Tall screens
        baseRadius *= 1.2; // Further orbit for tall screens
      }
      
      // Adjust for screen size
      const screenArea = screenWidth * screenHeight;
      if (screenArea < 800000) { // Small screens (mobile)
        baseRadius *= 0.7; // Much closer orbit
      } else if (screenArea > 2000000) { // Large screens
        baseRadius *= 1.1; // Slightly further orbit
      }
      
      // Consider camera distance
      if (camera) {
        const cameraDistance = camera.position.distanceTo(new THREE.Vector3());
        const cameraFactor = Math.min(cameraDistance / 22, 1.6); // Normalize camera distance
        baseRadius *= cameraFactor;
      }
      
      // Return base radius without constraints
      return baseRadius;
    }

    function calculateOcclusionRadius() {
      if (!earthModel || !camera) {
        console.log('‚ö†Ô∏è Missing earthModel or camera for occlusion calculation');
        const fallbackEarthRadius = window.earthRadius || 2;
        return fallbackEarthRadius * 1.5;
      }
      
      const earthWorldPosition = new THREE.Vector3();
      earthModel.getWorldPosition(earthWorldPosition);
      const earthRadius = window.earthRadius;
      const cameraToEarthCenter = camera.position.distanceTo(earthWorldPosition);
      const minimumVisibleRadius = earthRadius * 1.4;
      const cameraAllowance = Math.max(minimumVisibleRadius, cameraToEarthCenter - earthRadius - 2.6);
      const safeOcclusionRadius = Math.min(cameraAllowance, minimumVisibleRadius + earthRadius * 0.28);
      
      console.log('üìê Calculated occlusion radius:', safeOcclusionRadius.toFixed(2));
      console.log('üìê Camera distance from Earth:', cameraToEarthCenter.toFixed(2));
      console.log('üìê Earth radius:', earthRadius.toFixed(2));
      
      return safeOcclusionRadius;
    }

    function startDynamicTextRebending() {
      // Continuously check if text is blocked and rebend if necessary
      setInterval(() => {
        if (!textMesh1 || !earthModel) return;
        
        // Check if text is being blocked by Earth from camera view
        if (!camera) return;
        
        // Get text position relative to camera
        const textWorldPosition = new THREE.Vector3();
        textMesh1.getWorldPosition(textWorldPosition);
        
        // Get Earth center
        const earthWorldPosition = new THREE.Vector3();
        earthModel.getWorldPosition(earthWorldPosition);
        
        // Calculate distance from camera to text
        const cameraToText = textWorldPosition.distanceTo(camera.position);
        const cameraToEarth = earthWorldPosition.distanceTo(camera.position);
        
        // Check if text is behind Earth (blocked)
        // Calculate the minimum safe orbit radius dynamically
        // Calculate dynamic orbit radius based on current screen conditions
        const dynamicRadius = calculateDynamicOrbitRadius();
        const safeRadius = calculateOcclusionRadius();
        const cameraDistance = camera.position.length();
        const cameraLimit = Math.max(window.earthRadius * 1.6, cameraDistance - window.earthRadius - 2.6);
        const baseTarget = Math.max(dynamicRadius, safeRadius);
        const orbitMargin = Math.max((window.earthRadius || 0) * 0.1, 0.18);
        let targetRadius = Math.min(baseTarget + orbitMargin, cameraLimit);
        
        if (Math.abs(textOrbitRadius - targetRadius) > 0.05) {
          textOrbitRadius += (targetRadius - textOrbitRadius) * 0.2; // Ease toward target radius
          window.textOrbitRadius = textOrbitRadius;
          rebendTextGeometry();
        }
      }, 500); // Check every 500ms
    }

    // Handle window resize for dynamic orbit recalculation
    function handleWindowResize() {
      console.log('üì± Window resized, recalculating dynamic orbit radius');
      
      // Recalculate dynamic orbit radius
      const newDynamicRadius = calculateDynamicOrbitRadius();
      const currentSafeRadius = calculateOcclusionRadius();
      const cameraDistance = camera ? camera.position.length() : 28;
      const cameraLimit = Math.max(window.earthRadius * 1.6, cameraDistance - window.earthRadius - 2.6);
      const orbitMargin = Math.max((window.earthRadius || 0) * 0.1, 0.18);
      const desiredRadius = Math.max(newDynamicRadius, currentSafeRadius);
      const targetRadius = Math.min(desiredRadius + orbitMargin, cameraLimit);
      
      // Update text orbit radius if needed
      if (!window.textOrbitRadius || Math.abs(window.textOrbitRadius - targetRadius) > 0.1) {
        console.log('üîÑ Updating text orbit radius due to screen size change');
        window.textOrbitRadius = targetRadius;
        textOrbitRadius = targetRadius;
        rebendTextGeometry();
      }
      
      // Update camera aspect ratio
      if (camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      
      // Update renderer size
      if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }

    function startMaterialProtection() {
      // Continuously protect text material from being overridden
      setInterval(() => {
        const meshes = [window.textMesh1, window.textMesh2].filter(mesh => mesh && mesh.userData.originalMaterial);
        
        meshes.forEach(mesh => {
          // Check if material has been changed
          const currentMaterial = mesh.material;
          const originalMaterial = mesh.userData.originalMaterial;
          
          // If material color has changed from gold, restore it
          if (currentMaterial.color.getHex() !== 0xffd700 || 
              currentMaterial.emissive.getHex() !== 0xffd700) {
            console.log('üõ°Ô∏è Protecting text material from override');
            mesh.material = originalMaterial.clone();
            mesh.material.needsUpdate = true;
          }
        });
      }, 100); // Check every 100ms
    }

    function calculateOrbitRadiusForIndex(index, earthRadius) {
      // Start at 10% beyond Earth radius, then apply spacing
      const baseRadius = earthRadius * 1.1; // 10% beyond Earth
      const maxRadius = earthRadius * 1.35; // Maximum orbit radius
      const orbitRange = maxRadius - baseRadius;
      
      // Each object gets a specific offset to prevent collisions
      const baseOffset = orbitRange / 5; // Divide range into 5 segments
      const objectOffset = index * baseOffset; // Offset based on index
      const randomVariation = (Math.random() - 0.5) * baseOffset * 0.3; // Small random variation (¬±15%)
      
      // Calculate orbit radius with offset and variation
      return baseRadius + objectOffset + randomVariation;
    }

    function startOrbitalSequence() {
      if (orbitalObjects.length > 0) {
        console.log('üõ∞Ô∏è Orbital sequence already active, skipping restart');
        return;
      }
      console.log('üõ∞Ô∏è Starting orbital sequence with', glbFiles.length, 'objects');
      orbitAccumulator = 0;
      orbitCycleTracker = 0;
      completedOrbitCycles = 0;
      nextOrbitalIndex = 0;
      
      // Start introducing orbital objects every 7 seconds
      let orbitalTimer = 0;
      
      // Deploy first object immediately
      if (nextOrbitalIndex < glbFiles.length) {
        console.log('üöÄ Deploying orbital object', nextOrbitalIndex + 1, 'after', orbitalTimer, 'seconds (immediate)');
        createOrbitalObject(nextOrbitalIndex);
        nextOrbitalIndex += 1;
        orbitalTimer += 7;
      }
      
      const orbitalInterval = setInterval(() => {
        if (nextOrbitalIndex < glbFiles.length) {
          console.log('üöÄ Deploying orbital object', nextOrbitalIndex + 1, 'after', orbitalTimer, 'seconds');
          createOrbitalObject(nextOrbitalIndex);
          nextOrbitalIndex += 1;
          orbitalTimer += 7;
        } else {
          clearInterval(orbitalInterval);
          console.log('üõ∞Ô∏è All orbital objects deployed');
        }
      }, 7000); // Every 7 seconds
    }

    function createOrbitalObject(index) {
      if (index >= glbFiles.length) return;
      
      console.log(`üõ∞Ô∏è Creating orbital object ${index + 1} of ${glbFiles.length}`);
      
      // Create orbital group
      const orbitalGroup = new THREE.Group();
      orbitalGroups.push(orbitalGroup);
      
         // Add randomized orbital plane (more dynamic tilt variations)
         const tiltX = (Math.random() - 0.5) * 120; // Random tilt between -60 and +60 degrees
         const tiltY = (Math.random() - 0.5) * 60;  // Random Y-axis rotation for more variety
         const tiltZ = (Math.random() - 0.5) * 120; // Random tilt between -60 and +60 degrees
         orbitalGroup.rotation.x = tiltX * Math.PI / 180;
         orbitalGroup.rotation.y = tiltY * Math.PI / 180;
         orbitalGroup.rotation.z = tiltZ * Math.PI / 180;
      
      // Load GLB file for this orbit
      const loader = new GLTFLoader();
      const glbFile = glbFiles[index];
      
      console.log('üìÅ Loading GLB file:', glbFile);
      loader.load(glbFile, function(gltf) {
        try {
          console.log('‚úÖ GLB file loaded successfully:', glbFile);
          const model = gltf.scene.clone();
           
           // Calculate proper scale based on object's native dimensions relative to Earth
           const box = new THREE.Box3().setFromObject(model);
           const size = box.getSize(new THREE.Vector3());
           const maxDimension = Math.max(size.x, size.y, size.z);
           
           // Use global Earth radius for consistent scaling
           const earthRadius = window.earthRadius || (earthModel ? (() => {
             const earthBox = new THREE.Box3().setFromObject(earthModel);
             const earthSize = earthBox.getSize(new THREE.Vector3());
             return Math.max(earthSize.x, earthSize.y, earthSize.z) / 2;
           })() : 13); // Use 13 as fallback to match actual Earth size
           
           // Ensure we have a valid earth radius
           const safeEarthRadius = Math.max(earthRadius, 13);
           console.log(`üåç Using Earth radius ${safeEarthRadius.toFixed(2)} for orbital object ${index + 1} scaling`);
           const orbitRadius = calculateOrbitRadiusForIndex(index, safeEarthRadius);
           
           // All objects: 12.5% of Earth's diameter = 12.5% of (2 √ó radius) = 25% of radius
           const targetSize = safeEarthRadius * 2 * 0.125; // 12.5% of diameter for all objects
           const isPizza = glbFile.toLowerCase().includes('pizza');
           console.log(`${isPizza ? 'üçï' : 'ü™®'} Orbital object ${index + 1} target size: 15% of Earth diameter (${(safeEarthRadius * 2).toFixed(2)}), = ${targetSize.toFixed(2)}`);
           const scale = targetSize / maxDimension; // Use exact scale, no minimum constraint
           console.log(`üîç Scaling calculation: ${targetSize.toFixed(2)} / ${maxDimension.toFixed(2)} = ${scale.toFixed(4)}`);
           model.scale.setScalar(scale);
           
           console.log(`üìè Orbital object ${index + 1}: native size ${maxDimension.toFixed(2)}, scaled to ${(maxDimension * scale).toFixed(2)} (${((targetSize / safeEarthRadius) * 100).toFixed(1)}% of Earth radius)`);
           console.log(`üéØ Orbital object ${index + 1}: orbit radius ${orbitRadius.toFixed(2)}, random position`);
           
           // Position randomly around orbit
           const randomAngle = Math.random() * Math.PI * 2;
           model.position.set(
             Math.cos(randomAngle) * orbitRadius, 
             0, 
             Math.sin(randomAngle) * orbitRadius
           );
           
           // Center the model's origin for proper rotation around Earth
           model.position.add(box.getCenter(new THREE.Vector3()).multiplyScalar(-scale));
           
           // Add random initial rotation
           model.rotation.set(
             Math.random() * Math.PI * 2,
             Math.random() * Math.PI * 2,
             Math.random() * Math.PI * 2
           );
           
           // Store tumbling speeds for chaotic orbiting motion
           model.userData.tumbleX = (Math.random() - 0.5) * 0.025; // Much faster tumbling
           model.userData.tumbleY = (Math.random() - 0.5) * 0.025;
           model.userData.tumbleZ = (Math.random() - 0.5) * 0.025;
           
           // Store individual orbital speed (fast and varied)
           model.userData.orbitalSpeed = 0.8 + Math.random() * 0.6; // Much faster speed range
           
           // Fix materials for orbital objects - ensure they're properly lit without washing out textures
           model.traverse((child) => {
             if (!child.isMesh) return;

               child.castShadow = false; // Disabled for performance
               child.receiveShadow = false; // Disabled for performance
               
             const materials = Array.isArray(child.material) ? child.material : [child.material];
             materials.forEach((material) => {
               if (!material) return;

               // Pizza - apply colors by layer
               if (glbFile.toLowerCase().includes('pizza')) {
                 const meshName = child.name.toUpperCase();
                 
                 // Apply realistic pizza colors based on mesh name
                 if (meshName.includes('CHEESE')) {
                   material.color.set(0xffee44); // Bright yellow cheese
                   material.emissive.set(0x443300);
                   material.emissiveIntensity = 0.25;
                   console.log('üßÄ Cheese layer - bright yellow');
                 } else if (meshName.includes('BREAD')) {
                   material.color.set(0x995522); // Dark brown bread/crust
                   material.emissive.set(0x331100);
                   material.emissiveIntensity = 0.15;
                   console.log('üçû Bread layer - dark brown');
                 } else if (meshName.includes('PEPPERONI')) {
                   material.color.set(0xcc3333); // Red pepperoni
                   material.emissive.set(0x220000);
                   material.emissiveIntensity = 0.15;
                   console.log('üå∂Ô∏è Pepperoni layer - red');
                 } else {
                   // Default pizza color
                   material.color.set(0xff9966);
                   console.log('üçï Other pizza layer - orange');
                 }
                 
                 // Set realistic material properties
                 material.metalness = 0.0; // Not metallic
                 material.roughness = 0.9; // Matte surface
                 material.needsUpdate = true;
                 
                 return; // Skip other material processing for pizza
               }

               // Special royal blue material for K object (index 3)
               if (index === 3) {
                 material.color.set(0x4169e1); // Royal blue base color
                 material.metalness = 1.0; // 100% metalness - fully metallic
                 material.roughness = 0.2; // Slightly rougher for better visibility
                 material.clearcoat = 1.0; // Full clearcoat for shine
                 material.clearcoatRoughness = 0.1; // Smooth clearcoat
                 material.emissive.set(0xffaa00); // Bright golden emissive for visibility
                 material.emissiveIntensity = 0.8; // Strong emissive to brighten object
                 material.envMapIntensity = 3.0; // Strong environment reflections
                 material.reflectivity = 1.0; // Maximum reflectivity
                 material.sheen = 0.5; // Add sheen for extra shine
                 material.sheenRoughness = 0.2; // Smooth sheen
                 
                 // Ensure the material uses the scene environment for reflections
                 if (scene.environment) {
                   material.envMap = scene.environment;
                 }
                 
                 // Force material update for immediate effect
                 material.needsUpdate = true;
                 console.log('‚ú® Applied bright golden material to K object with enhanced visibility');
               } else {
                 // Standard material optimization for other objects
                 if (material.map) {
                   material.map.colorSpace = THREE.SRGBColorSpace;
                 }
               }

               material.needsUpdate = true;
             });
           });
           
           // Ensure model is not clipped and properly positioned
           model.traverse((child) => {
             if (child.isMesh) {
               child.frustumCulled = false; // Prevent clipping
             }
           });
           
           // Add to orbital group
           orbitalGroup.add(model);
           orbitalObjects.push(model);
           
           // Add orbital group directly to scene (not nested under Earth)
           scene.add(orbitalGroup);
           repaintScene();
           
           // Show bottom text notification for new orbital object
           try {
             showBottomTextForOrbitalObject(index);
           } catch (error) {
             console.warn(`‚ö†Ô∏è Could not show notification for orbital object ${index + 1}:`, error);
           }
           
           console.log(`‚úÖ Orbital object ${index + 1} added directly to scene (not nested under Earth)`);
           console.log(`‚úÖ Orbital object ${index + 1} (${glbFile}) added to scene with enhanced lighting`);
           console.log(`üìä Total orbital objects loaded: ${orbitalObjects.length}`);
         } catch (error) {
           console.error(`‚ùå Error in orbital object ${index + 1} processing:`, error);
           console.error(`‚ùå Error details:`, error.message || error);
         }
         }, function(progress) {
        console.log(`üìä Loading orbital object ${index + 1}:`, (progress.loaded / progress.total * 100) + '%');
      }, function(error) {
        console.log(`‚ö†Ô∏è Failed to load GLB file for orbital object ${index + 1}:`, error);
        console.log(`‚ö†Ô∏è Error details:`, error.message || error);
        console.log(`‚ö†Ô∏è GLB file path:`, glbFile);
      });
    }

    function createFallbackText() {
      // Fallback canvas text if font fails
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = isMobile ? 800 : 1200;
      canvas.height = isMobile ? 200 : 300;
      
      const fontSize = isMobile ? 20 : 28;
      const lineHeight = fontSize * 1.3;
      
      ctx.font = `bold ${fontSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#4169e1';
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      ctx.fillText('build the change you wish to see', centerX, centerY - lineHeight/2);
      ctx.fillText('in the world', centerX, centerY + lineHeight/2);
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      
      const planeWidth = isMobile ? 16 : 24;
      const planeHeight = isMobile ? 5 : 7;
      
      textMesh1 = new THREE.Mesh(new THREE.PlaneGeometry(planeWidth, planeHeight), material);
      textMesh1.position.set(0, 0, 0);
      textMesh1.rotation.y = Math.PI;
      group.add(textMesh1);
      repaintScene();
      console.log('‚úÖ Fallback text created');
    }

    function loadEarth() {
      console.log('üåç Loading Earth model...');
      const loader = new GLTFLoader();
      
      // Try GLB first
      console.log('üîç Attempting to load earth.glb...');
      loader.load('earth.glb', function(gltf) {
        console.log('‚úÖ Earth GLB loaded successfully');
        earthModel = gltf.scene;
        
        // Keep original materials from GLTF - don't override them
        earthModel.scale.setScalar(2);
        earthModel.position.set(0, 0, 0);
        
        // Add Earth directly to scene (not in rotating group)
        scene.add(earthModel);
        console.log('‚úÖ Earth GLB model loaded with original materials');
        if (!loadingFlags.earth) {
          loadingFlags.earth = true;
          markLoadingStep('Earth model ready');
        }
        ensureEarthShadowSettings();
        
        // Recreate text now that Earth is loaded for proper radius calculation
        console.log('üîÑ Recreating text with Earth model loaded');
        console.log('üåç Earth radius before text recreation:', earthRadius);
        
        // Use fallback radius if Earth model didn't load properly
        if (earthRadius === 0) {
          window.earthRadius = 13.0; // Use known Earth radius as fallback
          console.log('‚ö†Ô∏è Using fallback Earth radius:', window.earthRadius);
        }
        
        // Clear existing text before recreating (text is in group, not textGroup)
        if (textMesh1) {
          group.remove(textMesh1);
          textMesh1 = null;
        }
        
        console.log('üé® Calling createText() now that Earth is loaded...');
        createText();
        console.log('üé® createText() called, waiting for font to load...');
        // Text will mark itself as loaded after font loads
        
        repaintScene();
      }, function(progress) {
        console.log('üìä GLB loading progress:', (progress.loaded / progress.total * 100) + '%');
      }, function(error) {
        console.log('‚ö†Ô∏è Earth GLB load failed:', error);
        
        // Reset loader path and try GLTF
        loader.setPath('earth_gltf/');
        console.log('üîç Attempting to load GLTF from earth_gltf/scene.gltf...');
        loader.load('scene.gltf', function(gltf) {
          console.log('‚úÖ Earth GLTF loaded successfully');
          earthModel = gltf.scene;
          
          // Keep original materials from GLTF - don't override them
          earthModel.scale.setScalar(2);
          earthModel.position.set(earthPanX, earthPanY, earthPanZ);
          
          // Add Earth directly to scene (not in rotating group)
          scene.add(earthModel);
          console.log('‚úÖ Earth GLTF model loaded with original materials');
          if (!loadingFlags.earth) {
            loadingFlags.earth = true;
            markLoadingStep('Earth model ready');
          }
          ensureEarthShadowSettings();
          
          // Recreate text now that Earth is loaded for proper radius calculation
          console.log('üîÑ Recreating text with Earth model loaded');
          console.log('üåç Earth radius before text recreation:', earthRadius);
          
          // Use fallback radius if Earth model didn't load properly
          if (earthRadius === 0) {
            window.earthRadius = 13.0; // Use known Earth radius as fallback
            console.log('‚ö†Ô∏è Using fallback Earth radius:', window.earthRadius);
          }
          
          // Clear existing text before recreating (text is in group, not textGroup)
          if (textMesh1) {
            group.remove(textMesh1);
            textMesh1 = null;
          }
          
          console.log('üé® Calling createText() now that Earth is loaded...');
          createText();
          console.log('üé® createText() called, waiting for font to load...');
          // Text will mark itself as loaded after font loads
          
          repaintScene();
      }, function(progress) {
        console.log('üìä GLTF loading progress:', (progress.loaded / progress.total * 100) + '%');
        }, function(error2) {
          console.log('‚ö†Ô∏è Earth GLTF also failed:', error2);
          console.log('‚ùå No Earth model could be loaded - site cannot initialize');
          if (!loadingFlags.earth) {
            loadingFlags.earth = true;
            markLoadingStep('Earth model unavailable');
          }
          // Site fails if Earth loading fails - no fallback
        });
      });
    }


    // Create circular star texture

    function createStarTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      
      // Create radial gradient for circular star
      const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
      gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      
      context.fillStyle = gradient;
      context.fillRect(0, 0, 64, 64);
      
      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }

    function createEarthRing() {
      // Create Saturn-style ring around Earth
      const innerRadius = earthRadius * 1.3;
      const outerRadius = earthRadius * 1.8;
      const thetaSegments = 128;
      
      const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, thetaSegments);
      
      const ringMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xaaaaaa,
        metalness: 0.6,
        roughness: 0.4,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
        emissive: 0x222222,
        emissiveIntensity: 0.2
      });
      
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2; // Rotate to be horizontal around Earth
      ring.position.set(0, 0, 0); // Center on Earth
      scene.add(ring);
      
      console.log('‚úÖ Earth ring created');
      return ring;
    }

    function createStarfield() {
      // Create optimized starfield background for performance
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 50; // Reduced for performance while maintaining visual impact
      const starPositions = new Float32Array(starCount * 3);
      const starColors = new Float32Array(starCount * 3);
      const starSizes = new Float32Array(starCount);
      const twinkleSpeed = new Float32Array(starCount);
      const twinklePhase = new Float32Array(starCount);
      const twinkleAmplitude = new Float32Array(starCount);
      
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        
        // Scatter stars in a sphere around the origin
        const radius = 220 + Math.random() * 420; // 220-640 units away
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        
        starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        starPositions[i3 + 2] = radius * Math.cos(phi);
        
        // Assign a base colour temperature
        const paletteRoll = Math.random();
        if (paletteRoll < 0.6) {            // cool white / blue
          starColors[i3] = 0.85 + Math.random() * 0.15;
          starColors[i3 + 1] = 0.9 + Math.random() * 0.1;
          starColors[i3 + 2] = 1.0;
        } else if (paletteRoll < 0.85) {    // warm yellow
          starColors[i3] = 1.0;
          starColors[i3 + 1] = 0.92 + Math.random() * 0.06;
          starColors[i3 + 2] = 0.72 + Math.random() * 0.08;
        } else {                            // ember red
          starColors[i3] = 1.0;
          starColors[i3 + 1] = 0.6 + Math.random() * 0.1;
          starColors[i3 + 2] = 0.5 + Math.random() * 0.1;
        }
        
        // Unique twinkle signature per star
        twinkleSpeed[i] = 0.4 + Math.random() * 1.2;
        twinklePhase[i] = Math.random() * Math.PI * 2;
        twinkleAmplitude[i] = 0.25 + Math.random() * 0.35;
        
        // Subtle size variation
        starSizes[i] = 1.5 + Math.random() * 2.5; // 1.5 - 4.0
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
      starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
      
      const starMaterial = new THREE.PointsMaterial({
        size: 2.5, // Smaller for better performance
        transparent: true,
        opacity: 1.0,
        vertexColors: true,
        sizeAttenuation: true,
        alphaTest: 0.01,
        blending: THREE.AdditiveBlending,
        map: createStarTexture(),
        depthWrite: false,
        depthTest: true
      });
      
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
      repaintScene();
      
      // Add twinkling animation
      window.stars = stars; // Store reference for animation
      window.starBaseColors = new Float32Array(starColors); // Store immutable base colors
      window.starTwinkleSpeed = twinkleSpeed;
      window.starTwinklePhase = twinklePhase;
      window.starTwinkleAmplitude = twinkleAmplitude;
      
      console.log('‚úÖ Custom starfield created with', starCount, 'stars');
    }


    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      updateResponsiveFlags();
      
      // Recreate text with responsive sizing
      createText();
      repaintScene();
      console.log('üéâ Three.js initialization complete!');
    }

    // Initialize after DOM is ready
    init();

    function onPointerDown(event) {
      if (event.isPrimary === false) return;
      isPointerDown = true;
      pointerXOnPointerDown = event.clientX - windowHalfX;
      pointerYOnPointerDown = event.clientY - windowHalfY;
      targetRotationXOnPointerDown = targetRotationX;
      targetRotationYOnPointerDown = targetRotationY;
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerup', onPointerUp);
    }

    function onPointerMove(event) {
      if (event.isPrimary === false) return;
      pointerX = event.clientX - windowHalfX;
      pointerY = event.clientY - windowHalfY;
      targetRotationY = targetRotationYOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
      targetRotationX = targetRotationXOnPointerDown + (pointerY - pointerYOnPointerDown) * 0.02;
      
      // Clamp rotations to keep text readable - tighter range for better bubble density
      targetRotationY = Math.max(-Math.PI / 6, Math.min(Math.PI / 6, targetRotationY)); // ¬±30¬∞
      targetRotationX = Math.max(-Math.PI / 8, Math.min(Math.PI / 8, targetRotationX)); // ¬±22.5¬∞
    }

    function onPointerUp(event) {
      if (event.isPrimary === false) return;
      isPointerDown = false;
      document.removeEventListener('pointermove', onPointerMove);
      document.removeEventListener('pointerup', onPointerUp);
    }

    function animate(t) {
      // Log text orbit radius once to check actual value
      if (!animate.logged) {
        console.log('üéØüéØüéØ ACTUAL TEXT ORBIT RADIUS IN ANIMATION:', window.textOrbitRadius || textOrbitRadius);
        console.log('üåç Earth radius:', window.earthRadius || earthRadius);
        console.log('üé¨ Animation loop started');
        animate.logged = true;
      }
      
      // Orbital animation - full 360¬∞ sweep with subtle user steering
      orbitAccumulator = THREE.MathUtils.euclideanModulo(orbitAccumulator - orbitSpeed, Math.PI * 2);
      groupYawOffset += (targetRotationY - groupYawOffset) * 0.08;
      groupTiltX += (targetRotationX - groupTiltX) * 0.08;
      group.rotation.y = orbitAccumulator + groupYawOffset;
      group.rotation.x = groupTiltX;
      if (!isPointerDown) {
        targetRotationX *= 0.94;
        targetRotationY *= 0.94;
      }
      
      orbitCycleTracker += Math.abs(orbitSpeed);
      if (orbitCycleTracker >= Math.PI * 2) {
        orbitCycleTracker -= Math.PI * 2;
        completedOrbitCycles += 1;
        console.log('üîÅ Completed text orbit cycle', completedOrbitCycles);
        // Orbital objects now deployed on timer, not orbit cycles
      }
      
         // Rotate all orbital groups with individual speeds and add tumbling
         orbitalGroups.forEach((orbitalGroup, index) => {
           // Use individual orbital speed for each object (steady, slightly slower than text)
           const groupSpeed = orbitalGroup.children[0]?.userData.orbitalSpeed || 0.28;
           orbitalGroup.rotation.y += orbitSpeed * groupSpeed;
           
           // Add tumbling motion to each orbital object
           orbitalGroup.children.forEach((child) => {
             if (child.userData.tumbleX !== undefined) {
               child.rotation.x += child.userData.tumbleX;
               child.rotation.y += child.userData.tumbleY;
               child.rotation.z += child.userData.tumbleZ;
             }
           });
         });
      
      // Earth rotates slowly in opposite direction (1/4 speed of text)
      if (earthModel) {
        earthModel.rotation.y += earthRotationSpeed; // Use control variable
      }
      
      // Curved text doesn't need to face camera - it's already oriented outward
      
      // Camera stays fixed for clean, focused view
      const screenArea = window.innerWidth * window.innerHeight;
      const baseCameraDistance = 26;
      let targetCameraZ = baseCameraDistance;
      if (screenArea < 800000) {
        targetCameraZ = baseCameraDistance * 0.78;
      } else if (screenArea > 2000000) {
        targetCameraZ = baseCameraDistance * 1.18;
      }
      
      // Remove mouse parallax - keep camera centered
      camera.position.x = 0;
      camera.position.y = 0;
      camera.position.z += (targetCameraZ - camera.position.z) * 0.12;
      
      // Always look at the orbital center
      camera.lookAt(0, 0, 0);
      
        // Animate star twinkling with more dynamic patterns (never disappear)
        if (window.stars && window.starBaseColors) {
          const colors = window.stars.geometry.attributes.color.array;
          const baseColors = window.starBaseColors;
          const speeds = window.starTwinkleSpeed;
          const phases = window.starTwinklePhase;
          const amplitudes = window.starTwinkleAmplitude;
          const twinkleTime = (t || 0) * 0.0015;
          
          for (let i = 0, starIndex = 0; i < colors.length; i += 3, starIndex++) {
            const basePulse = Math.sin(twinkleTime * speeds[starIndex] + phases[starIndex]);
            const harmonics = Math.sin(twinkleTime * (speeds[starIndex] * 1.7) + phases[starIndex] * 1.3);
            const pulse = 0.65 + amplitudes[starIndex] * (0.5 * (basePulse + 1) + 0.2 * (harmonics + 1));
            const brightness = THREE.MathUtils.clamp(pulse, 0.45, 1.65);
            
            colors[i] = baseColors[i] * brightness;
            colors[i + 1] = baseColors[i + 1] * brightness;
            colors[i + 2] = baseColors[i + 2] * brightness;
          }
          window.stars.geometry.attributes.color.needsUpdate = true;
        }
      
      renderer.render(scene, camera);
    }

    function startMilitaryBanner() {
      const banner = document.getElementById('military-banner');
      const content = document.getElementById('banner-content');
      const cursor = banner.querySelector('.cursor');
      
      // Show cursor for 10 seconds first
      banner.classList.add('show');
      content.textContent = '';
      
      // After 10 seconds, start the message sequence
      setTimeout(() => {
        startMessageSequence();
      }, 10000);
      
      function startMessageSequence() {
        // Military messages - encrypted looking with translations
        const encryptedPhrases = [
          '01001000 01100101 01101100 01101100 01101111',
          '4B 79 72 6F 73',
          'SYS>INIT_CONNECTION',
          'ACCESS_GRANTED',
          'WELCOME TO THE FUTURE',
          'BUILD THE CHANGE YOU WISH TO SEE IN THE WORLD',
          'BUILD WITH US: hello@kyros.cc'
        ];
        
        // Translation messages to show after encrypted ones
        const translationPhrases = [
          'BINARY>HELLO',
          'HEX>KYROS',
          null, null, null, null,
          'CLICK TO BUILD'
        ];
        
        // Store clickable actions
        const clickableActions = [
          null, null, null, null, null, null,
          () => window.open('mailto:hello@kyros.cc')
        ];
        
        let currentMessage = 0;
        let currentChar = 0;
        let isTyping = true;
        let showDuration = 3000; // Show message for 3 seconds
        let hideDuration = 2000; // Hide for 2 seconds
        let clickableShowDuration = 8000; // Show clickable messages for 8 seconds
        let isHovering = false;
        let hideTimeout = null;
        let showingTranslation = false;
      
      function typeText() {
        if (!isTyping) return;
        
        const message = showingTranslation ? translationPhrases[currentMessage] : encryptedPhrases[currentMessage];
        if (currentChar < message.length) {
          content.textContent += message[currentChar];
          currentChar++;
          
          // Faster typing speed for better UX
          const delay = Math.random() * 30 + 20; // 20-50ms (much faster)
          setTimeout(typeText, delay);
        } else {
          // Message complete, show for duration then hide or show translation
          if (!showingTranslation && translationPhrases[currentMessage]) {
            // Show translation after encrypted message
            showingTranslation = true;
            setTimeout(() => {
              content.textContent = '';
              currentChar = 0;
              typeText();
            }, 1500); // Brief pause before translation
          } else {
            // Message sequence complete, hide banner
            const currentAction = clickableActions[currentMessage];
            const displayDuration = currentAction ? clickableShowDuration : showDuration;
            
            if (!isHovering) {
              hideTimeout = setTimeout(() => {
                hideBanner();
              }, displayDuration);
            }
          }
        }
      }
      
      function hideBanner() {
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
        
        banner.classList.remove('show');
        setTimeout(() => {
          content.textContent = '';
          currentChar = 0;
          showingTranslation = false;
          currentMessage = (currentMessage + 1) % encryptedPhrases.length;
          
          // Wait before showing next message
          setTimeout(() => {
            showBanner();
          }, hideDuration);
        }, 500); // Fade out time
      }
      
      function showBanner() {
        banner.classList.add('show');
        setTimeout(typeText, 500); // Small delay after fade in
        
        // Add click functionality for clickable messages
        const currentAction = clickableActions[currentMessage];
        if (currentAction) {
          banner.classList.add('clickable');
          banner.onclick = () => {
            currentAction();
            // Hide banner after click
            hideBanner();
          };
        } else {
          banner.classList.remove('clickable');
          banner.onclick = null;
        }
      }
      
      // Add hover event listeners
      banner.addEventListener('mouseenter', () => {
        const currentAction = clickableActions[currentMessage];
        if (currentAction) {
          isHovering = true;
          if (hideTimeout) {
            clearTimeout(hideTimeout);
            hideTimeout = null;
          }
          console.log('üñ±Ô∏è Hovering over clickable link - pausing banner');
        }
      });
      
      banner.addEventListener('mouseleave', () => {
        const currentAction = clickableActions[currentMessage];
        if (currentAction) {
          isHovering = false;
          // Resume hiding after a short delay
          setTimeout(() => {
            if (!isHovering) {
              hideBanner();
            }
          }, 1000);
          console.log('üñ±Ô∏è Left clickable link - resuming banner');
        }
      });
      
        // Start the sequence
        showBanner();
        
        // Add glitch effect to random characters
        setInterval(() => {
          if (Math.random() < 0.1) { // 10% chance
            const text = content.textContent;
            if (text.length > 0) {
              const randomIndex = Math.floor(Math.random() * text.length);
              const chars = '!@#$%^&*()_+-=[]{}|;:,.<>?';
              const randomChar = chars[Math.floor(Math.random() * chars.length)];
              
              const newText = text.substring(0, randomIndex) + randomChar + text.substring(randomIndex + 1);
              content.textContent = newText;
              
              // Restore original after brief moment
              setTimeout(() => {
                if (content.textContent === newText) {
                  content.textContent = text;
                }
              }, 100);
            }
          }
        }, 200);
      }
      
      console.log('üéñÔ∏è Military banner sequence started with 10-second cursor delay');
    }
  </script>
</body>
</html>
