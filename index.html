<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyros</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Helvetica Neue', Arial, sans-serif; }
    canvas { display: block; }
    #links {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: white;
      font-size: 14px;
      z-index: 10;
    }
    #links a {
      color: white;
      text-decoration: none;
      margin: 0 5px;
    }
    #links a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="links">
    Kyros investment studio / <a href="mailto:hello@kyros.cc">hello@kyros.cc</a> / <a href="https://calendly.com" target="_blank">Pitch us</a>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    let camera, scene, renderer;
    let textMesh1, textMesh2, textMesh3;
    let group;
    let targetRotationX = 0;
    let targetRotationY = 0;
    let targetRotationXOnPointerDown = 0;
    let targetRotationYOnPointerDown = 0;
    let pointerX = 0;
    let pointerY = 0;
    let pointerXOnPointerDown = 0;
    let pointerYOnPointerDown = 0;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    let currentComboIndex = 0;
    let isTransitioning = false;

    // Font and material combinations
    const fonts = [
      {
        url: 'https://cdn.jsdelivr.net/npm/three@0.169.0/examples/fonts/helvetiker_bold.typeface.json',
        size: 40,
        depth: 8,  // Reduced from 20 to 8
        bevel: 1,  // Reduced from 2 to 1
        // Responsive sizes
        mobileSize: 20,
        mobileDepth: 4,
        mobileBevel: 0.5
      }
    ];

    const matcapFiles = [
      'matcaps/chrome.png',
      'matcaps/gold.png',
      'matcaps/copper.png',
      'matcaps/colorful.png',
      'matcaps/metal.png',
      'matcaps/silver.png',
      'matcaps/red-plastic.png',
      'matcaps/green-plastic.png',
      'matcaps/leather.png',
      'matcaps/purple-pearl.png',
      'matcaps/dark-metal.png',
      'matcaps/blue-metal.png',
      'matcaps/ceramic.png',
      'matcaps/olive.png',
      'matcaps/orange-gold.png',
      'matcaps/wood.png',
      'matcaps/gunmetal.png',
      'matcaps/bronze.png',
      'matcaps/brass.png',
      'matcaps/rust.png'
    ];

    let loadedFonts = [];
    let loadedMatcaps = [];
    let currentMatcapIndex = 0;
    let bubbles = [];
    
    let mouseX = 0;
    let mouseY = 0;

    init();

    async function init() {
      // Camera
      camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
      camera.position.set(0, 200, 800);

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Renderer (must be created first)
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setAnimationLoop(animate);
      document.body.appendChild(renderer.domElement);

      // Lights
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(0, 0, 1).normalize();
      scene.add(dirLight);

      const pointLight = new THREE.PointLight(0xffffff, 4.5, 0, 0);
      pointLight.position.set(0, 100, 90);
      scene.add(pointLight);

      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);

      // Group
      group = new THREE.Group();
      group.position.y = 0;
      scene.add(group);

      // Create fewer but more realistic bubbles
      const bubbleCount = 15;  // Fewer for performance but better quality
      const bubbleGeometry = new THREE.SphereGeometry(1, 24, 24);  // Higher quality
      const bubbleMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.2,
        metalness: 0,
        roughness: 0.1,
        transmission: 0.95,
        thickness: 0.5,
        clearcoat: 1,
        clearcoatRoughness: 0,
        ior: 1.33  // Water refraction
      });
      
      for(let i = 0; i < bubbleCount; i++){
        const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial.clone());
        
        // Position bubbles in a sphere around origin (text center)
        // Some will be between camera and text (foreground)
        const radius = Math.random() * 600 + 200;  // 200-800 units from center
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        bubble.position.x = radius * Math.sin(phi) * Math.cos(theta);
        bubble.position.y = radius * Math.sin(phi) * Math.sin(theta);
        bubble.position.z = radius * Math.cos(phi);  // This puts some in front of text (positive z)
        
        // Larger bubbles when closer to camera
        const distanceToCamera = Math.abs(bubble.position.z - 800);
        bubble.scale.setScalar(THREE.MathUtils.mapLinear(distanceToCamera, 0, 1400, 15, 3));
        
        // Store animation params
        bubble.userData.radius = radius;
        bubble.userData.theta = theta;
        bubble.userData.phi = phi;
        bubble.userData.speed = Math.random() * 0.3 + 0.2;
        bubble.userData.offset = i;
        
        bubbles.push(bubble);
        scene.add(bubble);
      }

      // Load matcap textures
      const textureLoader = new THREE.TextureLoader();
      for (const matcapFile of matcapFiles) {
        try {
          const texture = await new Promise((resolve, reject) => {
            textureLoader.load(matcapFile, resolve, undefined, reject);
          });
          loadedMatcaps.push(texture);
        } catch (err) {
          console.warn('Failed to load matcap:', matcapFile, err);
        }
      }

      // Load all fonts
      const loader = new FontLoader();
      for (const fontConfig of fonts) {
        try {
          const font = await new Promise((resolve, reject) => {
            loader.load(fontConfig.url, resolve, undefined, reject);
          });
          loadedFonts.push({ font, config: fontConfig });
        } catch (err) {
          console.warn('Failed to load font:', fontConfig.url, err);
        }
      }

      if (loadedFonts.length === 0) {
        console.error('No fonts loaded');
        return;
      }

      // Create initial text
      createText(loadedFonts[0].font, loadedFonts[0].config, loadedMatcaps[0]);

      // Events
      document.addEventListener('pointerdown', onPointerDown);
      document.addEventListener('click', changeColor);
      document.addEventListener('mousemove', onMouseMove);
      window.addEventListener('resize', onWindowResize);
    }
    
    function onMouseMove(event) {
      mouseX = (event.clientX - windowHalfX) / 100;
      mouseY = (event.clientY - windowHalfY) / 100;
    }

    function createText(font, fontConfig, matcapTexture) {
      // Clear existing
      if (textMesh1) group.remove(textMesh1);
      if (textMesh2) group.remove(textMesh2);

      const material = new THREE.MeshMatcapMaterial({ matcap: matcapTexture });

      // Responsive sizing based on window width
      const isMobile = window.innerWidth < 768;
      const size = isMobile ? fontConfig.mobileSize : fontConfig.size;
      const depth = isMobile ? fontConfig.mobileDepth : fontConfig.depth;
      const bevel = isMobile ? fontConfig.mobileBevel : fontConfig.bevel;

      // Main text line 1
      const textGeo1 = new TextGeometry('build the change you wish', {
        font: font,
        size: size,
        depth: depth,
        curveSegments: 4,
        bevelThickness: bevel,
        bevelSize: bevel * 0.75,
        bevelEnabled: true
      });
      textGeo1.computeBoundingBox();
      const centerOffset1 = -0.5 * (textGeo1.boundingBox.max.x - textGeo1.boundingBox.min.x);
      
      textMesh1 = new THREE.Mesh(textGeo1, material);
      textMesh1.position.set(centerOffset1, 20, 0);
      group.add(textMesh1);

      // Main text line 2
      const textGeo2 = new TextGeometry('to see in the world', {
        font: font,
        size: size,
        depth: depth,
        curveSegments: 4,
        bevelThickness: bevel,
        bevelSize: bevel * 0.75,
        bevelEnabled: true
      });
      textGeo2.computeBoundingBox();
      const centerOffset2 = -0.5 * (textGeo2.boundingBox.max.x - textGeo2.boundingBox.min.x);
      
      textMesh2 = new THREE.Mesh(textGeo2, material.clone());
      textMesh2.position.set(centerOffset2, -40, 0);
      group.add(textMesh2);
    }

    function changeColor() {
      currentMatcapIndex = (currentMatcapIndex + 1) % loadedMatcaps.length;
      const matcapTexture = loadedMatcaps[currentMatcapIndex];
      
      // Update all text mesh materials with new matcap
      [textMesh1, textMesh2].forEach(mesh => {
        if (mesh) {
          mesh.material.matcap = matcapTexture;
          mesh.material.needsUpdate = true;
        }
      });
    }

    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Recreate text with responsive sizing
      if (loadedFonts.length > 0 && loadedMatcaps.length > 0) {
        const fontData = loadedFonts[0];
        createText(fontData.font, fontData.config, loadedMatcaps[currentMatcapIndex]);
      }
    }

    function onPointerDown(event) {
      if (event.isPrimary === false) return;
      pointerXOnPointerDown = event.clientX - windowHalfX;
      pointerYOnPointerDown = event.clientY - windowHalfY;
      targetRotationXOnPointerDown = targetRotationX;
      targetRotationYOnPointerDown = targetRotationY;
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerup', onPointerUp);
    }

    function onPointerMove(event) {
      if (event.isPrimary === false) return;
      pointerX = event.clientX - windowHalfX;
      pointerY = event.clientY - windowHalfY;
      targetRotationY = targetRotationYOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
      targetRotationX = targetRotationXOnPointerDown + (pointerY - pointerYOnPointerDown) * 0.02;
      
      // Clamp rotations to keep text readable
      targetRotationY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationY)); // ±60°
      targetRotationX = Math.max(-Math.PI / 6, Math.min(Math.PI / 6, targetRotationX)); // ±30°
    }

    function onPointerUp(event) {
      if (event.isPrimary === false) return;
      document.removeEventListener('pointermove', onPointerMove);
      document.removeEventListener('pointerup', onPointerUp);
    }

    function animate(t) {
      const time = (t || 0) * 0.0001;
      
      // Animate bubbles in orbital patterns around origin
      bubbles.forEach((bubble, i) => {
        const userData = bubble.userData;
        
        // Orbit around center in 3D
        const t = time * userData.speed + userData.offset;
        const theta = userData.theta + t * 0.5;
        const phi = userData.phi + Math.sin(t * 0.3) * 0.3;
        
        bubble.position.x = userData.radius * Math.sin(phi) * Math.cos(theta);
        bubble.position.y = userData.radius * Math.sin(phi) * Math.sin(theta);
        bubble.position.z = userData.radius * Math.cos(phi);
      });
      
      // Combine auto-pan with mouse follow
      const slowTime = time * 0.1;
      const autoPanX = Math.sin(slowTime) * 30;
      const autoPanY = Math.sin(slowTime * 1.5) * 20;
      
      // Target position combines auto-pan and mouse (10x amplification)
      const targetX = autoPanX + mouseX * 10;
      const targetY = 200 + autoPanY - mouseY * 10;
      
      // Smooth camera follow (faster response)
      camera.position.x += (targetX - camera.position.x) * 0.1;
      camera.position.y += (targetY - camera.position.y) * 0.1;
      
      group.rotation.y += (targetRotationY - group.rotation.y) * 0.05;
      group.rotation.x += (targetRotationX - group.rotation.x) * 0.05;
      camera.lookAt(0, 0, 0);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
