<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kyros</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      font-family: 'Helvetica Neue', Arial, sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #links {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: black;
      font-size: 12px;
      z-index: 10;
      white-space: nowrap;
      padding: 0 10px;
    }
    @media (max-width: 768px) {
      #links {
        font-size: 10px;
        bottom: 15px;
        padding: 0 5px;
      }
    }
    @media (max-width: 480px) {
      #links {
        font-size: 9px;
        bottom: 10px;
      }
    }
    #links a {
      color: black;
      text-decoration: none;
      margin: 0 3px;
    }
    #links a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="links">
    Kyros investment studio / <a href="mailto:hello@kyros.cc">hello@kyros.cc</a> / <a href="https://calendly.com" target="_blank">Pitch us</a>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';

    let camera, scene, renderer;
    let textMesh1;
    let group;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    let bubbles = [];
    let mouseX = 0;
    let mouseY = 0;

    function init() {
      console.log('🚀 Starting Three.js initialization...');
      
      // Camera positioned inside the bubble cloud for immersive parallax
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      camera.position.set(0, 0, 0);  // Center of the bubble field
      console.log('✅ Camera created');

      // Scene with clean white background
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff); // Clean white background
      scene.fog = new THREE.FogExp2(0xffffff, 0.005); // Subtle white fog for depth
      console.log('✅ Scene created with white background');
      
      // Load EXR environment map for metallic reflections only
      const exrLoader = new EXRLoader();
      exrLoader.load('machine_shop_01_4k.exr', function(texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = texture; // Keep environment for metallic reflections
        // Don't set as background - keep white background
      }, undefined, function(error) {
        console.log('EXR loading failed, continuing without environment map:', error);
      });

      // Renderer (must be created first)
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = false;
      document.body.appendChild(renderer.domElement);

      // Set up animation loop
      renderer.setAnimationLoop(animate);

      // No dynamic lighting for performance


      // Group
      group = new THREE.Group();
      group.position.y = 0;
      scene.add(group);

      // Create metallic ball bubbles
      const bubbleCount = 60;
      const bubbleGeometry = new THREE.SphereGeometry(1, 32, 32);
      const bubbleMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xdddddd,
        metalness: 0.9,
        roughness: 0.1,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        envMapIntensity: 1.5,
        transparent: true,
        opacity: 0.8
      });
      
      for(let i = 0; i < bubbleCount; i++){
        const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
        
        // Distribute metallic balls around text (responsive)
        const isMobile = window.innerWidth < 768;
        const spreadX = isMobile ? 200 : 300;
        const spreadY = isMobile ? 150 : 200;
        const spreadZ = isMobile ? 200 : 300;
        
        bubble.position.x = (Math.random() - 0.5) * spreadX;
        bubble.position.y = (Math.random() - 0.5) * spreadY - 50;
        
        // Some bubbles in front of text (positive Z), some behind (negative Z)
        const frontBubble = Math.random() < 0.3; // 30% chance to be in front
        if (frontBubble) {
          bubble.position.z = Math.random() * 50 + 5; // 5 to 55 (in front of text at -10)
        } else {
          bubble.position.z = (Math.random() - 0.5) * spreadZ - 20; // Behind text
        }
        
        // Vary metallic ball sizes (responsive)
        const isMobile = window.innerWidth < 768;
        const minSize = isMobile ? 2 : 3;
        const maxSize = isMobile ? 4 : 6;
        bubble.scale.setScalar(Math.random() * (maxSize - minSize) + minSize);
        
        // Simple soap bubble appearance (no complex shaders)
        
        // Store animation data for metallic balls
        bubble.userData = {
          speed: Math.random() * 0.3 + 0.1,
          rotationSpeed: Math.random() * 0.02 + 0.01,
          startY: bubble.position.y,
          size: bubble.scale.x
        };
        
        bubbles.push(bubble);
        scene.add(bubble);
      }
      console.log(`✅ Created ${bubbleCount} bubbles`);

      // Create initial text
      createText();

      // Events
      document.addEventListener('pointerdown', onPointerDown);
      document.addEventListener('mousemove', onMouseMove);
      window.addEventListener('resize', onWindowResize);
    }
    
    function onMouseMove(event) {
      mouseX = (event.clientX - windowHalfX) / 100;
      mouseY = (event.clientY - windowHalfY) / 100;
    }

    function createText() {
      console.log('📝 Creating text...');
      if (textMesh1) group.remove(textMesh1);

      // Create canvas texture for main text (2 lines)
      const canvas1 = document.createElement('canvas');
      const ctx1 = canvas1.getContext('2d');
      canvas1.width = 1000;
      canvas1.height = 300;
      
      // Responsive font size and canvas
      const isMobile = window.innerWidth < 768;
      const isSmallMobile = window.innerWidth < 480;
      const fontSize = isSmallMobile ? 16 : (isMobile ? 24 : 36);
      const lineHeight = fontSize * 1.2;
      
      // Adjust canvas size for mobile
      canvas1.width = isMobile ? 600 : 1000;
      canvas1.height = isMobile ? 200 : 300;
      
      ctx1.font = `bold ${fontSize}px Helvetica`;
      ctx1.fillStyle = '#2d5a27'; // Emerald green
      ctx1.textAlign = 'center';
      
      // Split text into 2 lines
      const line1 = 'build the change you wish to see';
      const line2 = 'in the world';
      
      const centerX = canvas1.width / 2;
      const centerY = canvas1.height / 2;
      
      ctx1.fillText(line1, centerX, centerY - lineHeight/2);
      ctx1.fillText(line2, centerX, centerY + lineHeight/2);
      
      const texture1 = new THREE.CanvasTexture(canvas1);
      const material1 = new THREE.MeshBasicMaterial({ map: texture1, transparent: true });
      
      // Responsive text plane size
      const planeWidth = isMobile ? 12 : 20;
      const planeHeight = isMobile ? 4 : 6;
      
      textMesh1 = new THREE.Mesh(new THREE.PlaneGeometry(planeWidth, planeHeight), material1);
      textMesh1.position.set(0, 1, -10);  // Center text vertically
      group.add(textMesh1);
      console.log('✅ Text mesh created and added to scene');

    }


    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Recreate text with responsive sizing
      createText();
      console.log('🎉 Three.js initialization complete!');
    }

    // Initialize after DOM is ready
    init();

    function onPointerDown(event) {
      if (event.isPrimary === false) return;
      pointerXOnPointerDown = event.clientX - windowHalfX;
      pointerYOnPointerDown = event.clientY - windowHalfY;
      targetRotationXOnPointerDown = targetRotationX;
      targetRotationYOnPointerDown = targetRotationY;
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerup', onPointerUp);
    }

    function onPointerMove(event) {
      if (event.isPrimary === false) return;
      pointerX = event.clientX - windowHalfX;
      pointerY = event.clientY - windowHalfY;
      targetRotationY = targetRotationYOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
      targetRotationX = targetRotationXOnPointerDown + (pointerY - pointerYOnPointerDown) * 0.02;
      
      // Clamp rotations to keep text readable
      targetRotationY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationY)); // ±60°
      targetRotationX = Math.max(-Math.PI / 6, Math.min(Math.PI / 6, targetRotationX)); // ±30°
    }

    function onPointerUp(event) {
      if (event.isPrimary === false) return;
      document.removeEventListener('pointermove', onPointerMove);
      document.removeEventListener('pointerup', onPointerUp);
    }

    function animate(t) {
      // Only log once to avoid spam
      if (!animate.logged) {
        console.log('🎬 Animation loop started');
        animate.logged = true;
      }
      
      const time = (t || 0) * 0.0001;
      
      // Animate metallic balls
      bubbles.forEach((bubble) => {
        const userData = bubble.userData;
        
        // Float upward
        bubble.position.y += userData.speed;
        
        // Rotate for metallic reflections
        bubble.rotation.x += userData.rotationSpeed;
        bubble.rotation.y += userData.rotationSpeed * 0.7;
        bubble.rotation.z += userData.rotationSpeed * 0.3;
        
        // Recycle balls that go too high (responsive)
        const isMobile = window.innerWidth < 768;
        const maxHeight = isMobile ? 150 : 200;
        const spreadX = isMobile ? 200 : 300;
        const spreadZ = isMobile ? 200 : 300;
        
        if (bubble.position.y > maxHeight) {
          bubble.position.y = userData.startY;
          bubble.position.x = (Math.random() - 0.5) * spreadX;
          
          // Maintain front/back distribution when recycling
          const frontBubble = Math.random() < 0.3; // 30% chance to be in front
          if (frontBubble) {
            bubble.position.z = Math.random() * 50 + 5; // 5 to 55 (in front of text)
          } else {
            bubble.position.z = (Math.random() - 0.5) * spreadZ - 20; // Behind text
          }
          bubble.rotation.set(0, 0, 0);
        }
      });
      
      // Text stays pinned to center - no rotation
      
      // Move camera around the fixed text
      const targetX = -mouseX * 2;  // Camera moves around text
      const targetY = mouseY * 2;   // Camera moves around text
      
      // Smooth camera movement around text
      camera.position.x += (targetX - camera.position.x) * 0.08;
      camera.position.y += (targetY - camera.position.y) * 0.08;
      camera.position.z = 0;  // Keep camera at same Z level
      
      camera.lookAt(0, 0, -10);  // Look at the text position
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
